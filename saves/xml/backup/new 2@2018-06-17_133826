Jupyter Notebook Assignment 4 Last Checkpoint: 3 hours ago Autosave Failed! Python 3
Python 3 
File
Edit
View
Insert
Cell
Kernel
Widgets
Help

You are currently looking at version 1.2 of this notebook. To download notebooks and datafiles, as well as get help on Jupyter notebooks in the Coursera platform, visit the Jupyter Notebook FAQ course resource.

Assignment 4

import networkx as nx
import pandas as pd
import numpy as np
import pickle
Part 1 - Random Graph Identification
For the first part of this assignment you will analyze randomly generated graphs and determine which algorithm created them.


P1_Graphs = pickle.load(open('A4_graphs','rb'))
P1_Graphs
[<networkx.classes.graph.Graph object at 0x7f2fe9028390>, <networkx.classes.graph.Graph object at 0x7f2fee857278>, <networkx.classes.graph.Graph object at 0x7f2fe9093fd0>, <networkx.classes.graph.Graph object at 0x7f2fe90936a0>, <networkx.classes.graph.Graph object at 0x7f2fe90930f0>]

P1_Graphs is a list containing 5 networkx graphs. Each of these graphs were generated by one of three possible algorithms:

Preferential Attachment ('PA')
Small World with low probability of rewiring ('SW_L')
Small World with high probability of rewiring ('SW_H')
Anaylze each of the 5 graphs and determine which of the three algorithms generated the graph.

The graph_identification function should return a list of length 5 where each element in the list is either 'PA', 'SW_L', or 'SW_H'.


def graph_identification():
    
    # Your Code Here
    graph_identification_list = []
    for G in P1_Graphs:
        average_clustering = nx.average_clustering(G)
        average_shortest_path_length = nx.average_shortest_path_length(G)
        if (average_clustering < 0.05) and (average_clustering > 0.01):
            graph_identification_list.append('PA')
        elif (average_clustering < 0.3) and (average_shortest_path_length < 7):
            graph_identification_list.append('SW_H')
        else:
            graph_identification_list.append('SW_L')
    
    return graph_identification_list # Your Answer Here
Part 2 - Company Emails
For the second part of this assignment you will be workking with a company's email network where each node corresponds to a person at the company, and each edge indicates that at least one email has been sent between two people.

The network also contains the node attributes Department and ManagementSalary.

Department indicates the department in the company which the person belongs to, and ManagementSalary indicates whether that person is receiving a management position salary.


G = nx.read_gpickle('email_prediction.txt')
​
print(nx.info(G))
Name: 
Type: Graph
Number of nodes: 1005
Number of edges: 16706
Average degree:  33.2458
Part 2A - Salary Prediction
Using network G, identify the people in the network with missing values for the node attribute ManagementSalary and predict whether or not these individuals are receiving a management position salary.

To accomplish this, you will need to create a matrix of node features using networkx, train a sklearn classifier on nodes that have ManagementSalary data, and predict a probability of the node receiving a management salary for nodes where ManagementSalary is missing.

Your predictions will need to be given as the probability that the corresponding employee is receiving a management position salary.

The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).

Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).

Using your trained classifier, return a series of length 252 with the data being the probability of receiving management salary, and the index being the node id.

Example:

    1       1.0
    2       0.0
    5       0.8
    8       1.0
        ...
    996     0.7
    1000    0.5
    1001    0.0
    Length: 252, dtype: float64

​
import math
from sklearn.ensemble import ExtraTreesClassifier
​
def salary_predictions():
    
    # Your Code Here
    nodes_list = G.nodes(data=True)
    ManagementSalary_dict = nx.get_node_attributes(G, 'ManagementSalary')
    training_node_list = []
    validation_node_list = []
    for node_id, is_salaried in ManagementSalary_dict.items():
        if str(is_salaried)=='nan':
            validation_node_list.append(node_id)
        else:
            training_node_list.append(node_id)
    degree_centrality_dict = nx.degree_centrality(G)
    eigenvector_centrality_dict = nx.eigenvector_centrality(G)
    eigenvector_centrality_numpy_dict = nx.eigenvector_centrality_numpy(G)
    phi = (1 + math.sqrt(len(nodes_list)+1)) / 2.0  # largest eigenvalue of adj matrix
    katz_centrality_numpy_dict = nx.katz_centrality_numpy(G, 1/phi)
    closeness_centrality_dict = nx.closeness_centrality(G)
    betweenness_centrality_dict = nx.betweenness_centrality(G)
    load_centrality_dict = nx.load_centrality(G)
    harmonic_centrality_dict = nx.harmonic_centrality(G)
    column_list = ['node_id', 'dept_id', 'is_salaried', 'node_degree', 'salaried_neighbors', 'nondepartmental_neighbors',
                   'degree_centrality', 'eigenvector_centrality', 'eigenvector_centrality_numpy', 'closeness_centrality',
                   'betweenness_centrality', 'load_centrality']
    row_list = []
    for node_id in training_node_list:
        row_dict = {}
        row_dict['node_id'] = node_id
        row_dict['dept_id'] = G.node[node_id]['Department']
        row_dict['is_salaried'] = G.node[node_id]['ManagementSalary']
        row_dict['node_degree'] = G.degree(node_id)
        salaried_neighbors = 0
        nondepartmental_neighbors = 0
        neighbors_list = G.neighbors(node_id)
        for n in neighbors_list:
            if G.node[n]['ManagementSalary'] == 1.0:
                salaried_neighbors += 1
            if G.node[n]['Department'] != row_dict['dept_id']:
                nondepartmental_neighbors += 1
        row_dict['salaried_neighbors'] = salaried_neighbors
        row_dict['nondepartmental_neighbors'] = nondepartmental_neighbors
        row_dict['degree_centrality'] = degree_centrality_dict[node_id]
        row_dict['eigenvector_centrality'] = eigenvector_centrality_dict[node_id]
        row_dict['eigenvector_centrality_numpy'] = eigenvector_centrality_numpy_dict[node_id]
        row_dict['closeness_centrality'] = closeness_centrality_dict[node_id]
        row_dict['betweenness_centrality'] = betweenness_centrality_dict[node_id]
        row_dict['load_centrality'] = load_centrality_dict[node_id]
        row_list.append(row_dict)
    node_features_df = pd.DataFrame(data=row_list, columns=column_list)
    forest = ExtraTreesClassifier(n_estimators=250)
    column_list = [c for c in node_features_df.columns if (c is not 'is_salaried') and (c is not 'node_id')]
    X = node_features_df[column_list].as_matrix()
    y = node_features_df['is_salaried'].as_matrix()
    forest.fit(X, y)
    row_list = []
    for node_id in validation_node_list:
        row_dict = {}
        row_dict['node_id'] = node_id
        row_dict['dept_id'] = G.node[node_id]['Department']
        row_dict['node_degree'] = G.degree(node_id)
        salaried_neighbors = 0
        nondepartmental_neighbors = 0
        neighbors_list = G.neighbors(node_id)
        for n in neighbors_list:
            if G.node[n]['ManagementSalary'] == 1.0:
                salaried_neighbors += 1
            if G.node[n]['Department'] != row_dict['dept_id']:
                nondepartmental_neighbors += 1
        row_dict['salaried_neighbors'] = salaried_neighbors
        row_dict['nondepartmental_neighbors'] = nondepartmental_neighbors
        row_dict['degree_centrality'] = degree_centrality_dict[node_id]
        row_dict['eigenvector_centrality'] = eigenvector_centrality_dict[node_id]
        row_dict['eigenvector_centrality_numpy'] = eigenvector_centrality_numpy_dict[node_id]
        row_dict['closeness_centrality'] = closeness_centrality_dict[node_id]
        row_dict['betweenness_centrality'] = betweenness_centrality_dict[node_id]
        row_dict['load_centrality'] = load_centrality_dict[node_id]
        row_list.append(row_dict)
    column_list = [c for c in node_features_df.columns if (c is not 'is_salaried')]
    missing_salary_df = pd.DataFrame(data=row_list, columns=column_list)
    column_list = [c for c in missing_salary_df.columns if (c is not 'node_id')]
    prediction_ndarray = forest.predict_proba(missing_salary_df[column_list].as_matrix())
    index_list = []
    data_list = []
    for node_id, class_probability_array in zip(missing_salary_df['node_id'].as_matrix(), prediction_ndarray):
        index_list.append(node_id)
        data_list.append(class_probability_array[1])
    probability_series = pd.Series(data=data_list, index=index_list)
    
    return probability_series # Your Answer Here
Part 2B - New Connections Prediction
For the last part of this assignment, you will predict future connections between employees of the network. The future connections information has been loaded into the variable future_connections. The index is a tuple indicating a pair of nodes that currently do not have a connection, and the Future Connection column indicates if an edge between those two nodes will exist in the future, where a value of 1.0 indicates a future connection.



future_connections.sample(10)
future_connections = pd.read_csv('Future_Connections.csv', index_col=0, converters={0: eval})
future_connections.sample(10)
Future Connection
(264, 929)	0.0
(466, 958)	NaN
(835, 884)	NaN
(194, 444)	0.0
(269, 672)	NaN
(369, 519)	NaN
(491, 932)	0.0
(583, 929)	NaN
(508, 773)	NaN
(62, 831)	NaN

​
import math
from sklearn.ensemble import ExtraTreesClassifier
​
# Your Code Here
future_connections_dict = future_connections.to_dict()['Future Connection']
training_edge_list = []
validation_edge_list = []
for edge_id, connection_probability in future_connections_dict.items():
    if str(connection_probability)=='nan':
        validation_edge_list.append(edge_id)
    else:
        training_edge_list.append(edge_id)

resource_allocation_index
​
prediction_generator = nx.jaccard_coefficient(G, random.sample(training_edge_list, 10))
for u, v, p in prediction_generator:
    print('({}, {}) -> {:.8f}'.format(u, v, p))
(672, 939) -> 0.00000000
(92, 408) -> 0.06451860
(223, 456) -> 0.00588235
(76, 448) -> 0.02500000
(398, 490) -> 0.01895895
(283, 385) -> 0.37852852
(617, 929) -> 0.06486643
(202, 476) -> 0.00000000
(497, 602) -> 0.00000000
(177, 581) -> 0.09089490

​
prediction_generator = nx.jaccard_coefficient(G, training_edge_list)
for u, v, p in prediction_generator:
    match_series = (future_connections.index == '({}, {})'.format(u, v))
    future_connections[match_series]['jaccard_coefficient'] = p
future_connections.sample(10)

resource_allocation_index
​
import random
​
prediction_generator = nx.adamic_adar_index(G, random.sample(training_edge_list, 10))
for u, v, p in prediction_generator:
    print('({}, {}) -> {:.8f}'.format(u, v, p))
(672, 939) -> 0.00000000
(92, 408) -> 0.06451860
(223, 456) -> 0.00588235
(76, 448) -> 0.02500000
(398, 490) -> 0.01895895
(283, 385) -> 0.37852852
(617, 929) -> 0.06486643
(202, 476) -> 0.00000000
(497, 602) -> 0.00000000
(177, 581) -> 0.09089490

resource_allocation_index
​
prediction_generator = nx.adamic_adar_index(G, training_edge_list)
for u, v, p in prediction_generator:
    match_series = (future_connections.index == '({}, {})'.format(u, v))
    future_connections[match_series]['adamic_adar_index'] = p
future_connections.sample(10)

​
prediction_generator = nx.preferential_attachment(G, random.sample(training_edge_list, 10))
for u, v, p in prediction_generator:
    print('({}, {}) -> {:.8f}'.format(u, v, p))
(672, 939) -> 0.00000000
(92, 408) -> 0.06451860
(223, 456) -> 0.00588235
(76, 448) -> 0.02500000
(398, 490) -> 0.01895895
(283, 385) -> 0.37852852
(617, 929) -> 0.06486643
(202, 476) -> 0.00000000
(497, 602) -> 0.00000000
(177, 581) -> 0.09089490

preferential_attachment
​
prediction_generator = nx.preferential_attachment(G, training_edge_list)
for u, v, p in prediction_generator:
    match_series = (future_connections.index == '({}, {})'.format(u, v))
    future_connections[match_series]['preferential_attachment'] = p
future_connections.sample(10)

​
import random
​
prediction_generator = nx.cn_soundarajan_hopcroft(G, random.sample(training_edge_list, 10), community='Department')
for u, v, p in prediction_generator:
    print('({}, {}) -> {:.8f}'.format(u, v, p))
(672, 939) -> 0.00000000
(92, 408) -> 0.06451860
(223, 456) -> 0.00588235
(76, 448) -> 0.02500000
(398, 490) -> 0.01895895
(283, 385) -> 0.37852852
(617, 929) -> 0.06486643
(202, 476) -> 0.00000000
(497, 602) -> 0.00000000
(177, 581) -> 0.09089490

_
​
prediction_generator = nx.cn_soundarajan_hopcroft(G, training_edge_list, community='Department')
for u, v, p in prediction_generator:
    match_series = (future_connections.index == '({}, {})'.format(u, v))
    future_connections[match_series]['cn_soundarajan_hopcroft_Department'] = p
future_connections.sample(10)

Department
​
import random
​
prediction_generator = nx.cn_soundarajan_hopcroft(G, random.sample(training_edge_list, 10), community='ManagementSalary')
for u, v, p in prediction_generator:
    print('({}, {}) -> {:.8f}'.format(u, v, p))
(672, 939) -> 0.00000000
(92, 408) -> 0.06451860
(223, 456) -> 0.00588235
(76, 448) -> 0.02500000
(398, 490) -> 0.01895895
(283, 385) -> 0.37852852
(617, 929) -> 0.06486643
(202, 476) -> 0.00000000
(497, 602) -> 0.00000000
(177, 581) -> 0.09089490

​
prediction_generator = nx.cn_soundarajan_hopcroft(G, training_edge_list, community='ManagementSalary')
for u, v, p in prediction_generator:
    match_series = (future_connections.index == '({}, {})'.format(u, v))
    future_connections[match_series]['cn_soundarajan_hopcroft_ManagementSalary'] = p
future_connections.sample(10)

cn_soundarajan_hopcroft
​
import random
​
prediction_generator = nx.ra_index_soundarajan_hopcroft(G, random.sample(training_edge_list, 10), community='Department')
for u, v, p in prediction_generator:
    print('({}, {}) -> {:.8f}'.format(u, v, p))
(672, 939) -> 0.00000000
(92, 408) -> 0.06451860
(223, 456) -> 0.00588235
(76, 448) -> 0.02500000
(398, 490) -> 0.01895895
(283, 385) -> 0.37852852
(617, 929) -> 0.06486643
(202, 476) -> 0.00000000
(497, 602) -> 0.00000000
(177, 581) -> 0.09089490

cn_soundarajan_hopcroft
​
prediction_generator = nx.ra_index_soundarajan_hopcroft(G, training_edge_list, community='Department')
for u, v, p in prediction_generator:
    match_series = (future_connections.index == '({}, {})'.format(u, v))
    future_connections[match_series]['ra_index_soundarajan_hopcroft_Department'] = p
future_connections.sample(10)

cn_soundarajan_hopcroft
​
import random
​
prediction_generator = nx.ra_index_soundarajan_hopcroft(G, random.sample(training_edge_list, 10), community='ManagementSalary')
for u, v, p in prediction_generator:
    print('({}, {}) -> {:.8f}'.format(u, v, p))
(672, 939) -> 0.00000000
(92, 408) -> 0.06451860
(223, 456) -> 0.00588235
(76, 448) -> 0.02500000
(398, 490) -> 0.01895895
(283, 385) -> 0.37852852
(617, 929) -> 0.06486643
(202, 476) -> 0.00000000
(497, 602) -> 0.00000000
(177, 581) -> 0.09089490

cn_soundarajan_hopcroft
​
prediction_generator = nx.ra_index_soundarajan_hopcroft(G, training_edge_list, community='ManagementSalary')
for u, v, p in prediction_generator:
    match_series = (future_connections.index == '({}, {})'.format(u, v))
    future_connections[match_series]['ra_index_soundarajan_hopcroft_ManagementSalary'] = p
future_connections.sample(10)

ManagementSalary
​
degree_centrality_dict = nx.degree_centrality(G)
eigenvector_centrality_dict = nx.eigenvector_centrality(G)
eigenvector_centrality_numpy_dict = nx.eigenvector_centrality_numpy(G)
edges_list = G.edges(data=True)
phi = (1 + math.sqrt(len(edges_list)+1)) / 2.0  # largest eigenvalue of adj matrix
katz_centrality_numpy_dict = nx.katz_centrality_numpy(G, 1/phi)
closeness_centrality_dict = nx.closeness_centrality(G)
betweenness_centrality_dict = nx.betweenness_centrality(G)
load_centrality_dict = nx.load_centrality(G)
harmonic_centrality_dict = nx.harmonic_centrality(G)
column_list = ['edge_id', 'dept_id', 'connection_probability', 'edge_degree', 'salaried_neighbors', 'nondepartmental_neighbors',
               'degree_centrality', 'eigenvector_centrality', 'eigenvector_centrality_numpy', 'closeness_centrality',
               'betweenness_centrality', 'load_centrality']
row_list = []
for edge_id in training_edge_list:
    row_dict = {}
    row_dict['edge_id'] = edge_id
    row_dict['dept_id'] = G.edge[edge_id]['Department']
    row_dict['connection_probability'] = G.edge[edge_id]['ManagementSalary']
    row_dict['edge_degree'] = G.degree(edge_id)
    salaried_neighbors = 0
    nondepartmental_neighbors = 0
    neighbors_list = G.neighbors(edge_id)
    for n in neighbors_list:
        if G.edge[n]['ManagementSalary'] == 1.0:
            salaried_neighbors += 1
        if G.edge[n]['Department'] != row_dict['dept_id']:
            nondepartmental_neighbors += 1
    row_dict['salaried_neighbors'] = salaried_neighbors
    row_dict['nondepartmental_neighbors'] = nondepartmental_neighbors
    row_dict['degree_centrality'] = degree_centrality_dict[edge_id]
    row_dict['eigenvector_centrality'] = eigenvector_centrality_dict[edge_id]
    row_dict['eigenvector_centrality_numpy'] = eigenvector_centrality_numpy_dict[edge_id]
    row_dict['closeness_centrality'] = closeness_centrality_dict[edge_id]
    row_dict['betweenness_centrality'] = betweenness_centrality_dict[edge_id]
    row_dict['load_centrality'] = load_centrality_dict[edge_id]
    row_list.append(row_dict)
edge_features_df = pd.DataFrame(data=row_list, columns=column_list)
forest = ExtraTreesClassifier(n_estimators=250)
column_list = [c for c in edge_features_df.columns if (c is not 'connection_probability') and (c is not 'edge_id')]
X = edge_features_df[column_list].as_matrix()
y = edge_features_df['connection_probability'].as_matrix()
forest.fit(X, y)
row_list = []
for edge_id in validation_edge_list:
    row_dict = {}
    row_dict['edge_id'] = edge_id
    row_dict['dept_id'] = G.edge[edge_id]['Department']
    row_dict['edge_degree'] = G.degree(edge_id)
    salaried_neighbors = 0
    nondepartmental_neighbors = 0
    neighbors_list = G.neighbors(edge_id)
    for n in neighbors_list:
        if G.edge[n]['ManagementSalary'] == 1.0:
            salaried_neighbors += 1
        if G.edge[n]['Department'] != row_dict['dept_id']:
            nondepartmental_neighbors += 1
    row_dict['salaried_neighbors'] = salaried_neighbors
    row_dict['nondepartmental_neighbors'] = nondepartmental_neighbors
    row_dict['degree_centrality'] = degree_centrality_dict[edge_id]
    row_dict['eigenvector_centrality'] = eigenvector_centrality_dict[edge_id]
    row_dict['eigenvector_centrality_numpy'] = eigenvector_centrality_numpy_dict[edge_id]
    row_dict['closeness_centrality'] = closeness_centrality_dict[edge_id]
    row_dict['betweenness_centrality'] = betweenness_centrality_dict[edge_id]
    row_dict['load_centrality'] = load_centrality_dict[edge_id]
    row_list.append(row_dict)
column_list = [c for c in edge_features_df.columns if (c is not 'connection_probability')]
missing_salary_df = pd.DataFrame(data=row_list, columns=column_list)
column_list = [c for c in missing_salary_df.columns if (c is not 'edge_id')]
prediction_ndarray = forest.predict_proba(missing_salary_df[column_list].as_matrix())
index_list = []
data_list = []
for edge_id, class_probability_array in zip(missing_salary_df['edge_id'].as_matrix(), prediction_ndarray):
    index_list.append(edge_id)
    data_list.append(class_probability_array[1])
probability_series = pd.Series(data=data_list, index=index_list)
​
probability_series # Your Answer Here
Using network G and future_connections, identify the edges in future_connections with missing values and predict whether or not these edges will have a future connection.

To accomplish this, you will need to create a matrix of features for the edges found in future_connections using networkx, train a sklearn classifier on those edges in future_connections that have Future Connection data, and predict a probability of the edge being a future connection for those edges in future_connections where Future Connection is missing.

Your predictions will need to be given as the probability of the corresponding edge being a future connection.

The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).

Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).

Using your trained classifier, return a series of length 122112 with the data being the probability of the edge being a future connection, and the index being the edge as represented by a tuple of nodes.

Example:

    (107, 348)    0.35
    (542, 751)    0.40
    (20, 426)     0.55
    (50, 989)     0.35
              ...
    (939, 940)    0.15
    (555, 905)    0.35
    (75, 101)     0.65
    Length: 122112, dtype: float64

def new_connections_predictions():
    
    # Your Code Here
    
    return # Your Answer Here
