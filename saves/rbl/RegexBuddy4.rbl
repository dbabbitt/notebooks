<?xml version="1.0" encoding="UTF-8"?>
<rxb:regexbuddy xmlns:rxb="http://www.regexbuddy.com/regexbuddy47.xsd" version="4.7">
	<libraryfile>
		<action id="AddressZIPcodeUS">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[0-9]{5}(?:-[0-9]{4})?\b</regex>
			<description>Address: ZIP code (US)</description>
			<teststring><![CDATA[1234
12345
123456
123456789
12345-6789]]></teststring>
		</action>
		<action id="ColumnsMatcharegexstartingataspecificcolumnonaline" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^.{%SKIPAMOUNT%}(%REGEX%)</regex>
			<description>Columns: Match a regex starting at a specific column on a line.</description>
			<parameter description="Number of characters to skip at the start of the line" defaultvalue="10">%SKIPAMOUNT%</parameter>
			<parameter description="The regex to be matched at column skipamount+1" defaultvalue="regex">%REGEX%</parameter>
		</action>
		<action id="ColumnsRangeofcharactersonalinecapturedintobackreference1" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^.{%SKIPAMOUNT%}(.{%CAPTUREAMOUNT%})</regex>
			<description>Columns: Range of characters on a line, captured into backreference 1&#13;&#10;Iterate over all matches to extract a column of text from a file&#13;&#10;E.g. to grab the characters in colums 8..10, set SKIPAMOUNT to 7, and CAPTUREAMOUNT to 3</description>
			<parameter description="Number of characters to skip at the start of the line" defaultvalue="10">%SKIPAMOUNT%</parameter>
			<parameter description="Number of characters to capture" defaultvalue="10">%CAPTUREAMOUNT%</parameter>
		</action>
		<action id="CreditcardAllmajorcreditcardsbare" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$</regex>
			<description>Credit card: All major credit cards (bare)&#13;&#10;Checks if a series of digits is possibly a valid credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardAllmajorcreditcardsbarenamed" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:&#13;&#10;(?&lt;visa>4[0-9]{12}(?:[0-9]{3})?) |&#13;&#10;(?&lt;mastercard>(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}) |&#13;&#10;(?&lt;discover>6(?:011|5[0-9][0-9])[0-9]{12}) |&#13;&#10;(?&lt;amex>3[47][0-9]{13}) |&#13;&#10;(?&lt;diners>3(?:0[0-5]|[68][0-9])[0-9]{11}) |&#13;&#10;(?&lt;jcb>(?:2131|1800|35\d{3})\d{11})&#13;&#10;)$</regex>
			<description>Credit card: All major credit cards (bare, named)&#13;&#10;Checks if a series of digits is possibly a valid credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardAllmajorcreditcardsgrouped" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:4\d{3}[ -]*\d{4}[ -]*\d{4}[ -]*\d(?:\d{3})?|(?:5[1-5]\d{2}|222[1-9]|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)[ -]*\d{4}[ -]*\d{4}[ -]*\d{4}|6(?:011|5\d{2})[ -]*\d{4}[ -]*\d{4}[ -]*\d{4}|3[47]\d{2}[ -]*\d{6}[ -]*\d{5}|3(?:0[0-5]|[68]\d)\d[ -]*\d{6}[ -]*\d{4}|(?:2131|1800)[ -]*\d{6}[ -]*\d{5}|35\d{2}[ -]*\d{4}[ -]*\d{4}[ -]*\d{4})$</regex>
			<description>Credit card: All major credit cards (grouped)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardAllmajorcreditcardsgroupednamed" freespacing="1" testscope="line">
			<flavor>
				<builtin>pcre1020</builtin>
			</flavor>
			<regex>^(?:&#13;&#10;(?&lt;visa>4\d{3}[ -]*\d{4}[ -]*\d{4}[ -]*\d(?:\d{3})?) |&#13;&#10;(?&lt;mastercard>(?:5[1-5]\d{2}|222[1-9]|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)[ -]*\d{4}[ -]*\d{4}[ -]*\d{4}) |&#13;&#10;(?&lt;discover>6(?:011|5[0-9]{2})[ -]*\d{4}[ -]*\d{4}[ -]*\d{4}) |&#13;&#10;(?&lt;amex>3[47]\d{2}[ -]*\d{6}[ -]*\d{5}) |&#13;&#10;(?&lt;diners>3(?:0[0-5]|[68][0-9])\d[ -]*\d{6}[ -]*\d{4}) |&#13;&#10;(?&lt;jcb>(?:2131|1800)[ -]*\d{6}[ -]*\d{5}|35\d{2}[ -]*\d{4}[ -]*\d{4}[ -]*\d{4})&#13;&#10;)$</regex>
			<description>Credit card: All major credit cards (grouped, named)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardAllmajorcreditcardsspacesdashes" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ -]*(?:4[ -]*(?:\d[ -]*){11}(?:(?:\d[ -]*){3})?\d|5[ -]*[1-5](?:[ -]*[0-9]){14}|6[ -]*(?:0[ -]*1[ -]*1|5[ -]*\d[ -]*\d)(?:[ -]*[0-9]){12}|3[ -]*[47](?:[ -]*[0-9]){13}|3[ -]*(?:0[ -]*[0-5]|[68][ -]*[0-9])(?:[ -]*[0-9]){11}|(?:2[ -]*1[ -]*3[ -]*1|1[ -]*8[ -]*0[ -]*0|3[ -]*5(?:[ -]*[0-9]){3})(?:[ -]*[0-9]){11})[ -]*$</regex>
			<description>Credit card: All major credit cards (spaces/dashes)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardAllmajorcreditcardsspacesdashesnamed" freespacing="1" testscope="line">
			<flavor>
				<builtin>pcre1020</builtin>
			</flavor>
			<regex>^[ -]*(?:&#13;&#10;(?&lt;visa>4[ -]*(?:\d[ -]*){11}(?:(?:\d[ -]*){3})?\d) |&#13;&#10;(?&lt;mastercard>(?:5[ -]*[1-5](?:[ -]*\d){2}|(?:2[ -]*){3}[1-9]|(?:2[ -]*){2}[3-9][ -]*\d|2[ -]*[3-6](?:[ -]*\d){2}|2[ -]*7[ -]*[01][ -]*\d|2[ -]*7[ -]*2[ -]*0)(?:[ -]*\d){12}) |&#13;&#10;(?&lt;discover>6[ -]*(?:0[ -]*1[ -]*1|5[ -]*\d[ -]*\d)(?:[ -]*[0-9]){12}) |&#13;&#10;(?&lt;amex>3[ -]*[47](?:[ -]*[0-9]){13}) |&#13;&#10;(?&lt;diners>3[ -]*(?:0[ -]*[0-5]|[68][ -]*[0-9])(?:[ -]*[0-9]){11}) |&#13;&#10;(?&lt;jcb>(?:2[ -]*1[ -]*3[ -]*1|1[ -]*8[ -]*0[ -]*0|3[ -]*5(?:[ -]*[0-9]){3})(?:[ -]*[0-9]){11})&#13;&#10;)[ -]*$</regex>
			<description>Credit card: All major credit cards (spaces/dashes, named)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardAmericanExpressbare" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^3[47][0-9]{13}$</regex>
			<description>Credit card: American Express (bare)&#13;&#10;Checks if a series of digits is possibly a valid American Express credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardAmericanExpressgrouped" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^3[47]\d{2}[ -]*\d{6}[ -]*\d{5}$</regex>
			<description>Credit card: American Express (grouped)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardAmericanExpressspacesdashes" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ -]*3[ -]*[47][ -]*(?:\d[ -]*){13}$</regex>
			<description>Credit card: American Express (spaces/dashes)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardDinersClubbare" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^3(?:0[0-5]|[68][0-9])[0-9]{11}$</regex>
			<description>Credit card: Diners Club (bare)&#13;&#10;Checks if a series of digits is possibly a valid Diners Club credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardDinersClubgrouped" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^3(?:0[0-5]|[68][0-9])\d[ -]*\d{6}[ -]*\d{4}$</regex>
			<description>Credit card: Diners Club (grouped)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardDinersClubspacesdashes" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ -]*3[ -]*(?:0[ -]*[0-5]|[68][ -]*[0-9])[ -]*(?:\d[ -]*){11}$</regex>
			<description>Credit card: Diners Club (spaces/dashes)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardDiscoverbare" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^6(?:011|5[0-9]{2})[0-9]{12}$</regex>
			<description>Credit card: Discover (bare)&#13;&#10;Checks if a series of digits is possibly a valid Discover credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardDiscovergrouped" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^6(?:011|5[0-9]{2})[ -]*\d{4}[ -]*\d{4}[ -]*\d{4}$</regex>
			<description>Credit card: Discover (grouped)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardDiscoverspacesdashes" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ -]*6[ -]*(?:0[ -]*1[ -]*1|5[ -]*\d[ -]*\d)[ -]*(?:\d[ -]*){12}$</regex>
			<description>Credit card: Discover (spaces/dashes)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardJCBbare" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:2131|1800|35\d{3})\d{11}$</regex>
			<replace>&lt;a href="#$1">$1&lt;/a></replace>
			<description>Credit card: JCB (bare)&#13;&#10;Checks if a series of digits is possibly a valid JCB credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardJCBgrouped" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:(?:2131|1800)[ -]*\d{6}[ -]*\d{5}|35\d{2}[ -]*\d{4}[ -]*\d{4}[ -]*\d{4})$</regex>
			<replace>&lt;a href="#$1">$1&lt;/a></replace>
			<description>Credit card: JCB (grouped)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardJCBspacesdashes" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ -]*(?:2[ -]*1[ -]*3[ -]*1|1[ -]*8[ -]*0[ -]*0|3[ -]*5(?:[ -]*\d){3})[ -]*(?:\d[ -]*){11}$</regex>
			<replace>&lt;a href="#$1">$1&lt;/a></replace>
			<description>Credit card: JCB (spaces/dashes)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardMasterCardbare" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$</regex>
			<description>Credit card: MasterCard (bare)&#13;&#10;Checks if a series of digits is possibly a valid MasterCard credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardMasterCardgrouped" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:5[1-5]\d{2}|222[1-9]|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)[ -]*\d{4}[ -]*\d{4}[ -]*\d{4}$</regex>
			<description>Credit card: MasterCard (grouped)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardMasterCardspacesdashes" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ -]*(?:5[ -]*[1-5](?:[ -]*\d){2}|(?:2[ -]*){3}[1-9]|(?:2[ -]*){2}[3-9][ -]*\d|2[ -]*[3-6](?:[ -]*\d){2}|2[ -]*7[ -]*[01][ -]*\d|2[ -]*7[ -]*2[ -]*0)(?:[ -]*\d){12}[ -]*$</regex>
			<description>Credit card: MasterCard (spaces/dashes)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="Creditcardremovenondigits" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[^0-9]+</regex>
			<description>Credit card: remove non-digits&#13;&#10;Before using one of the other regular expressions in this library to test credit card numbers, use this regular expression to remove non-digits (particularly dashes and spaces) from the input string.</description>
		</action>
		<action id="CreditcardVisabare" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^4[0-9]{12}(?:[0-9]{3})?$</regex>
			<description>Credit card: Visa (bare)&#13;&#10;Checks if a series of digits is possibly a valid Visa credit card number.&#13;&#10;Use this regex, after removing non-digits, to speed up credit card transactions by filtering out obviously invalid card numbers before sending the order to the credit card processor.</description>
			<teststring><![CDATA[Visa
4234567890123
4234567890123456

423456789012
42345678901234
423456789012345
42345678901234567

MasterCard
5123567890123456
2221567890123456
2720567890123456

512356789012345
5923567890123456
2220567890123456
2721567890123456
51235678901234567

Discover
6011123456789012
6512345678901234

601112345678901
60111234567890123

American Express
341234567890123
371234567890123

34123456789012
301234567890123
3712345678901234

Diner's Club
30012345678901
30512345678901
36012345678901
36912345678901
38012345678901
38912345678901

30612345678901
37012345678901

JCB
213112345678901
180012345678901
3512345678901234

21311234567890
18001234567890
2131123456789012
1800123456789012
35123456789012

Random
123456789012345
]]></teststring>
		</action>
		<action id="CreditcardVisagrouped" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^4\d{3}[ -]*\d{4}[ -]*\d{4}[ -]*\d(?:\d{3})?$</regex>
			<description>Credit card: Visa (grouped)&#13;&#10;Search for credit card numbers that can be grouped in logical blocks as on the credit card itself.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
4234567890123
4234 5678 9012 3456
4234-5678-9012-3456

MasterCard
5123567890123456
2221 5678 9012 3456
2720-5678-9012-3456

Discover
6011123456789012
6011-1234-5678-9012
6011 1234 5678 9012

American Express
341234567890123
3412 345678 90123
3412-345678-90123

Diner's Club
30012345678901
3001 234567 8901
3001-234567-8901

JCB
213112345678901
2131 123456 78901
2131-123456-78901
3512345678901234
3512 3456 7890 1234
3512-3456-7890-1234
]]></teststring>
		</action>
		<action id="CreditcardVisaspacesdashes" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ -]*4[ -]*(?:\d[ -]*){12}(?:(?:\d[ -]*){3})?$</regex>
			<description>Credit card: Visa (spaces/dashes)&#13;&#10;Search for credit card numbers with any amount of spaces or dashes in them.  Use this if you can't remove non-digits first.</description>
			<teststring><![CDATA[Visa
  4 1-23 4567-890 12
41 234-567 890-123--45

4123456789-01
412345678 90123
4123 45678901-234
41234 567-890123456

MasterCard
  51 2356789--0123456
2221 5678 90-12 3456
2720-5678-90 12-3456

51 234567 8901234
59-235678-90123456
2220 567890123456
2721-567890123456
51234-567890-123455

Discover
601-1123 456789-012
651234-5678 901-234

60-111 2345 678901
60111  2345-678-90123

American Express
3412345 -678-90123
371-2345678901-23

3412-345 6789012
301234567-8901 23
37 12345678-90 1234

Diners Club
 300-1234 5678901
3051-2345 678901-
36012-3456 78901
 369123-4567 8901
3801234-5678 901
38912345-6789 01

3061234  567 8901
37012--345 678901

JCB
21 3112-34567890-1
180 0123-456789-01
3512 3456-78901234

21311 2345-67890
180012 3456-7890
2131123 4567-89012
18001234 5678-9012
351234567 8901-2

Random
123456789012345
]]></teststring>
		</action>
		<action id="CSVAnyfield" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>"[^"\r\n]*"|[^,\r\n]*</regex>
			<description>CSV: Any field&#13;&#10;Matches any single field in a CSV file.  Use this regex to iterate over all fields.</description>
		</action>
		<action id="CSVAnyfieldwithextrawhitespace" caseless="1" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[ \t]*+"[^"\r\n]*+"[ \t]*+|[^,\r\n]*+</regex>
			<replace>%MATCH:40L%</replace>
			<description>CSV: Any field with extra whitespace&#13;&#10;Matches any single field in a CSV file.  Use this regex to iterate over all fields.&#13;&#10;Includes extra whitespace before and after double-quoted fields in the regex match.</description>
		</action>
		<action id="CSVChangedelimiter" purpose="replace" multiline="1" namedduplicate="1">
			<flavor>
				<builtin>pgr4</builtin>
			</flavor>
			<regex>("[^"\r\n]*")?,(?![^",\r\n]*"$)</regex>
			<replace>$1\t</replace>
			<description>CSV: Change delimiter&#13;&#10;Changes the delimiter from a comma into a tab.&#13;&#10;The capturing group makes sure delimiters inside double-quoted entries are ignored.&#13;&#10;The negative lookahead makes sure delimiters between double quotes in the last field are ignored.&#13;&#10;Replace both commas in the regex and the tab at the end of the replacement to convert between any two delimiters.</description>
		</action>
		<action id="CSVCompleterowallfields" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*)$</regex>
			<description>CSV: Complete row, all fields.&#13;&#10;Match complete rows in a comma-delimited file that has 3 fields per row, capturing each field into a backreference.  To match CSV rows with more or fewer fields, simply duplicate or delete the capturing groups.</description>
			<teststring><![CDATA[one,two,three
one,"two",three
one,"two,and,a,half",three

one,two
one,two,three,four
]]></teststring>
		</action>
		<action id="CSVCompleterowcertainfields" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:(?:"[^"\r\n]*"|[^,\r\n]*),){%SKIPLEAD%}("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*)(?:(?:"[^"\r\n]*"|[^,\r\n]*),){%SKIPTRAIL%}$</regex>
			<description>CSV: Complete row, certain fields.&#13;&#10;Set %SKIPLEAD% to the number of fields you want to skip at the start, and %SKIPTRAIL% to the number of fields you want to ignore at the end of each row.  This regex captures 3 fields into backreferences.  To capture more or fewer fields, simply duplicate or delete the capturing groups.</description>
			<parameter description="Fields to skip at the start of each row" defaultvalue="1">%SKIPLEAD%</parameter>
			<parameter description="Fields to ignore at the end of each row" defaultvalue="1">%SKIPTRAIL%</parameter>
		</action>
		<action id="CSVDeleteafield" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^((?:(?:"[^"\r\n]*"|[^,\r\n]*),){%SKIPLEAD%})(?:"[^"\r\n]*"|[^,\r\n]*),</regex>
			<replace>$1</replace>
			<description>CSV: Delete a field&#13;&#10;Delete one field from a CSV file.  To delete field 3, set %SKIPLEAD% to 2.</description>
			<parameter description="Fields to skip at the start of each row" defaultvalue="2">%SKIPLEAD%</parameter>
		</action>
		<action id="CSVDeletefields" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^((?:(?:"[^"\r\n]*"|[^,\r\n]*),){%SKIPLEAD%})(?:(?:"[^"\r\n]*"|[^,\r\n]*),){%FIELDS%}</regex>
			<replace>$1</replace>
			<description>CSV: Delete fields&#13;&#10;To delete fields 4 and 5, set %SKIPLEAD% to 3 and %FIELDS% to 2.</description>
			<parameter description="Fields to skip at the start of each row" defaultvalue="3">%SKIPLEAD%</parameter>
			<parameter description="Number of fields to delete" defaultvalue="2">%FIELDS%</parameter>
		</action>
		<action id="CSVDeletethefirstfewfields" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:(?:"[^"\r\n]*"|[^,\r\n]*),){%FIELDS%}</regex>
			<description>CSV: Delete the first few fields</description>
			<parameter description="Number of fields to delete" defaultvalue="2">%FIELDS%</parameter>
		</action>
		<action id="CSVDeletethefirstfield" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:"[^"\r\n]*"|[^,\r\n]*),</regex>
			<description>CSV: Delete the first field</description>
		</action>
		<action id="CSVDeletethelastfewfields" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?:,(?:"[^"\r\n]*"|[^,\r\n]*)){%FIELDS%}$</regex>
			<description>CSV: Delete the last few fields</description>
			<parameter description="Number of fields to delete" defaultvalue="2">%FIELDS%</parameter>
		</action>
		<action id="CSVDeletethelastfield" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>,(?:"[^"\r\n]*"|[^,\r\n]*)$</regex>
			<description>CSV: Delete the last field</description>
		</action>
		<action id="CSVPartialrowcertainfields" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:(?:"[^"\r\n]*"|[^,\r\n]*),){%SKIPLEAD%}("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*)</regex>
			<description>CSV: Partial row, certain fields&#13;&#10;Match the first SKIPLEAD+3 fields of each rows in a comma-delimited file that has SKIPLEAD+3 or more fields per row.  The 3 fields after SKIPLEAD are each captured into a backreference.  All other fields are ignored.  Rows that have less than SKIPLEAD+3 fields are skipped.  To capture more or fewer fields, simply duplicate or delete the capturing groups.</description>
			<parameter description="Fields to skip at the start of each row" defaultvalue="1">%SKIPLEAD%</parameter>
		</action>
		<action id="CSVPartialrowleadingfields" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*),("[^"\r\n]*"|[^,\r\n]*)</regex>
			<description>CSV: Partial row, leading fields&#13;&#10;Match the first 3 fields of each rows in a comma-delimited file that has 3 or more fields per row.  The first 3 fields are each captured into a backreference.  All other fields are ignored.  Rows that have less than 3 fields are skipped.  To capture more or fewer fields, simply duplicate or delete the capturing groups.</description>
			<teststring><![CDATA[one,two,three
one,"two",three
one,"two,and,a,half",three

one,two
one,two,three,four
]]></teststring>
		</action>
		<action id="CSVPartialrowvariableleadingfields" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^("[^"\r\n]*"|[^,\r\n]*)(?:,("[^"\r\n]*"|[^,\r\n]*)(?:,("[^"\r\n]*"|[^,\r\n]*))?)?</regex>
			<description>CSV: Partial row, variable leading fields&#13;&#10;Match the first 3 fields of each rows in a comma-delimited file.  The first 3 fields are each captured into a backreference.  All other fields are ignored.  If a row has fewer than 3 field, some of the backreferences will remain empty.  To capture more or fewer fields, simply duplicate or delete the capturing groups.  The question mark after each group makes that group optional.</description>
			<teststring><![CDATA[one,two,three
one,"two",three
one,"two,and,a,half",three

one,two
one,two,three,four
]]></teststring>
		</action>
		<action id="Datedmyyandddmmyyyy">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(0?[1-9]|[12][0-9]|3[01])[- /.](0?[1-9]|1[012])[- /.](19|20)?[0-9]{2}\b</regex>
			<description>Date d/m/yy and dd/mm/yyyy&#13;&#10;1/1/00 through 31/12/99 and 01/01/1900 through 31/12/2099&#13;&#10;Matches invalid dates such as February 31st&#13;&#10;Accepts dashes, spaces, forward slashes and dots as date separators</description>
			<teststring><![CDATA[1/1/00
01/01/00
31/12/99 dd/mm
12/31/99 mm/dd
1-1-00
01-01-00
31.12.00 dd.mm
12.31.00 mm.dd

1/1/1900
01/01/1900
31/12/2099 dd/mm
12/31/1999 mm/dd
1-1-2000
01-01-2000
31.12.2000 dd.mm
12.31.2000 mm.dd

1900-01-01
2099-12-31
1900-1-1
99-01-01
99-1-1
1999/12/31
1999.12.31
]]></teststring>
		</action>
		<action id="Dateddmmyyyy">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)[0-9]{2}\b</regex>
			<description>Date dd/mm/yyyy&#13;&#10;01/01/1900 through 31/12/2099&#13;&#10;Matches invalid dates such as February 31st&#13;&#10;Accepts dashes, spaces, forward slashes and dots as date separators</description>
			<teststring><![CDATA[1/1/00
01/01/00
31/12/99 dd/mm
12/31/99 mm/dd
1-1-00
01-01-00
31.12.00 dd.mm
12.31.00 mm.dd

1/1/1900
01/01/1900
31/12/2099 dd/mm
12/31/1999 mm/dd
1-1-2000
01-01-2000
31.12.2000 dd.mm
12.31.2000 mm.dd

1900-01-01
2099-12-31
1900-1-1
99-01-01
99-1-1
1999/12/31
1999.12.31
]]></teststring>
		</action>
		<action id="Datemdyandmmddyyyy">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}\b</regex>
			<description>Date m/d/y and mm/dd/yyyy&#13;&#10;1/1/99 through 12/31/99 and 01/01/1900 through 12/31/2099&#13;&#10;Matches invalid dates such as February 31st&#13;&#10;Accepts dashes, spaces, forward slashes and dots as date separators</description>
			<teststring><![CDATA[1/1/00
01/01/00
31/12/99 dd/mm
12/31/99 mm/dd
1-1-00
01-01-00
31.12.00 dd.mm
12.31.00 mm.dd

1/1/1900
01/01/1900
31/12/2099 dd/mm
12/31/1999 mm/dd
1-1-2000
01-01-2000
31.12.2000 dd.mm
12.31.2000 mm.dd

1900-01-01
2099-12-31
1900-1-1
99-01-01
99-1-1
1999/12/31
1999.12.31
]]></teststring>
		</action>
		<action id="DatemdyytoMonthNthyyyy" purpose="replace" freespacing="1" multiline="1" namedduplicate="1">
			<flavor>
				<builtin>pgr5</builtin>
			</flavor>
			<regex>\b&#13;&#10;(?: # Month&#13;&#10;   (?'jan'0?1)|(?'feb'0?2)|(?'mar'0?3)|(?'apr'0?4)|(?'may'0?5)|(?'jun'0?6)&#13;&#10;  |(?'jul'0?7)|(?'aug'0?8)|(?'sep'0?9)|(?'oct'10)|(?'nov'11)|(?'dec'12)&#13;&#10;  ) /&#13;&#10;0?(?: # Day&#13;&#10;   (?'1st'[123]?1)|(?'2nd'[12]?2)|(?'3rd'[12]?3)|(?'nth'30|[12]?[4-90])&#13;&#10;  ) /&#13;&#10;(?: # Year&#13;&#10;   (?'19xx'[5-9][0-9])|(?'20xx'[0-4][0-9])&#13;&#10;  )&#13;&#10;\b</regex>
			<replace>(?{jan}January)(?{feb}February)(?{mar}March)(?{apr}April)(?{may}May)(?{jun}June)(?{jul}July)(?{aug}August)(?{sep}September)(?{oct}October)(?{nov}November)(?{dec}December) (?{1st}${1st}st)(?{2nd}${2nd}nd)(?{3rd}${3rd}rd)(?{nth}${nth}th), (?{19xx}19${19xx})(?{20xx}20${20xx})</replace>
			<description>Date m/d/yy to Month Nth, yyyy&#13;&#10;Replace numerical dates from 1/1/50 or 01/01/50 through 12/31/49 with their textual equivalents from January 1st, 1950 through December 31st, 2049</description>
			<teststring><![CDATA[1/1/50
02/2/51
3/03/70
04/04/80
5/10/90
6/11/99
7/12/00
8/13/01
9/14/20
10/29/30
11/30/48
12/31/49]]></teststring>
		</action>
		<action id="Datemmddyyyy">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.](19|20)[0-9]{2}\b</regex>
			<description>Date mm/dd/yyyy&#13;&#10;01/01/1900 through 12/31/2099&#13;&#10;Matches invalid dates such as February 31st&#13;&#10;Accepts dashes, spaces, forward slashes and dots as date separators</description>
			<teststring><![CDATA[1/1/00
01/01/00
31/12/99 dd/mm
12/31/99 mm/dd
1-1-00
01-01-00
31.12.00 dd.mm
12.31.00 mm.dd

1/1/1900
01/01/1900
31/12/2099 dd/mm
12/31/1999 mm/dd
1-1-2000
01-01-2000
31.12.2000 dd.mm
12.31.2000 mm.dd

1900-01-01
2099-12-31
1900-1-1
99-01-01
99-1-1
1999/12/31
1999.12.31
]]></teststring>
		</action>
		<action id="Dateyymdoryyyymmdd">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])\b</regex>
			<description>Date yy-m-d or yyyy-mm-dd&#13;&#10;00-1-1 through 99-12-31 and 1900-01-01 through 2099-12-31&#13;&#10;Matches invalid dates such as February 31st&#13;&#10;Accepts dashes, spaces, forward slashes and dots as date separators</description>
			<teststring><![CDATA[1/1/00
01/01/00
31/12/99 dd/mm
12/31/99 mm/dd
1-1-00
01-01-00
31.12.00 dd.mm
12.31.00 mm.dd

1/1/1900
01/01/1900
31/12/2099 dd/mm
12/31/1999 mm/dd
1-1-2000
01-01-2000
31.12.2000 dd.mm
12.31.2000 mm.dd

1900-01-01
2099-12-31
1900-1-1
99-01-01
99-1-1
1999/12/31
1999.12.31
]]></teststring>
		</action>
		<action id="Dateyyyymmdd">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(19|20)[0-9]{2}[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])\b</regex>
			<description>Date yyyy-mm-dd&#13;&#10;1900-01-01 through 2099-12-31&#13;&#10;Matches invalid dates such as February 31st&#13;&#10;Accepts dashes, spaces, forward slashes and dots as date separators</description>
			<teststring><![CDATA[1/1/00
01/01/00
31/12/99 dd/mm
12/31/99 mm/dd
1-1-00
01-01-00
31.12.00 dd.mm
12.31.00 mm.dd

1/1/1900
01/01/1900
31/12/2099 dd/mm
12/31/1999 mm/dd
1-1-2000
01-01-2000
31.12.2000 dd.mm
12.31.2000 mm.dd

1900-01-01
2099-12-31
1900-1-1
99-01-01
99-1-1
1999/12/31
1999.12.31
]]></teststring>
		</action>
		<action id="DelimitersReplacecommaswithtabs" purpose="replace" caseless="1" multiline="1" namedduplicate="1">
			<flavor>
				<builtin>pgr4</builtin>
			</flavor>
			<regex>((?:"[^"]*+")|[^,]++)*+,</regex>
			<replace>$1\t</replace>
			<description>Delimiters: Replace commas with tabs&#13;&#10;Replaces commas with tabs, except for commas inside double-quoted strings</description>
			<teststring><![CDATA[one,two,"not,here",four]]></teststring>
		</action>
		<action id="Domainname" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\b</regex>
			<description>Domain name</description>
			<teststring><![CDATA[www.regexbuddy.com
www.regular-expressions.info]]></teststring>
		</action>
		<action id="Domainnameanchored" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$</regex>
			<description>Domain name (anchored)</description>
			<teststring><![CDATA[www.regexbuddy.com
www.regular-expressions.info]]></teststring>
		</action>
		<action id="Domainnameinternationalized" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\b</regex>
			<description>Domain name (internationalized)&#13;&#10;Allow internationalized domains using punycode notation, as well as regular domain names</description>
			<teststring><![CDATA[www.regexbuddy.com
www.regular-expressions.info]]></teststring>
		</action>
		<action id="Domainnameinternationalizedstrict" caseless="1" freespacing="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b((?=[a-z0-9-]{1,63}\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,63}\b</regex>
			<description>Domain name (internationalized, strict)&#13;&#10;Allow internationalized domains using punycode notation, as well as regular domain names&#13;&#10;Use lookahead to check that each part of the domain name is 63 characters or less</description>
		</action>
		<action id="Domainnamestrict" caseless="1" freespacing="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b((?=[a-z0-9-]{1,63}\.)[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,63}\b</regex>
			<description>Domain name (strict)&#13;&#10;Use lookahead to check that each part of the domain name is 63 characters or less</description>
		</action>
		<action id="Emailaddress1" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b</regex>
			<description>Email address 1&#13;&#10;Use this version to seek out email addresses in random documents and texts.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com]]></teststring>
		</action>
		<action id="Emailaddress1anchored" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$</regex>
			<description>Email address 1 (anchored)&#13;&#10;Use this anchored version to check whether a valid email address was entered.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com]]></teststring>
		</action>
		<action id="Emailaddress2anchorednoconsecutivedots" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[A-Z0-9][A-Z0-9._%+-]*@(?:[A-Z0-9-]+\.)+[A-Z]{2,}$</regex>
			<description>Email address 2 (anchored; no consecutive dots)&#13;&#10;Use this anchored version to check whether a valid email address was entered.&#13;&#10;Improves on the original email address regex by excluding addresses with consecutive dots such as john@aol...com and addresses that don't start with a letter or digit.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com]]></teststring>
		</action>
		<action id="Emailaddress2noconsecutivedots" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[A-Z0-9][A-Z0-9._%+-]*@(?:[A-Z0-9-]+\.)+[A-Z]{2,}\b</regex>
			<description>Email address 2 (no consecutive dots)&#13;&#10;Use this version to seek out email addresses in random documents and texts.&#13;&#10;Improves on the original email address regex by excluding addresses with consecutive dots such as john@aol...com and addresses that don't start with a letter or digit.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com]]></teststring>
		</action>
		<action id="Emailaddress3anchoredlimitlengthofeachpart" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[A-Z0-9][A-Z0-9._%+-]{0,63}@(?:[A-Z0-9-]{1,63}\.){1,8}[A-Z]{2,63}$</regex>
			<description>Email address 3 (anchored; limit length of each part)&#13;&#10;Use this anchored version to check whether a valid email address was entered.&#13;&#10;Improves on the original email address regex by excluding addresses with consecutive dots and limiting the length of each dotted part and the part before the @.&#13;&#10;Can match email addresses longer than 254 characters which SMTP cannot handle.  Use procedural code to check that the length of the string is between 6 and 254 characters before using this regex if you want to validate both the length of the whole email address as well as the length of each part.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com]]></teststring>
		</action>
		<action id="Emailaddress3limitlengthofeachpart" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[A-Z0-9][A-Z0-9._%+-]{0,63}@(?:[A-Z0-9-]{1,63}\.){1,8}[A-Z]{2,63}\b</regex>
			<description>Email address 3 (limit length of each part)&#13;&#10;Use this version to seek out email addresses in random documents and texts.&#13;&#10;Improves on the original email address regex by excluding addresses with consecutive dots and limiting the length of each dotted part and the part before the @.&#13;&#10;Can match email addresses longer than 254 characters which SMTP cannot handle.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com]]></teststring>
		</action>
		<action id="Emailaddress4anchoredlimittotallengthandlengthofeachpart" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?=[A-Z0-9][A-Z0-9@._%+-]{5,253}$)[A-Z0-9._%+-]{1,64}@(?:[A-Z0-9-]{1,63}\.)+[A-Z]{2,63}$</regex>
			<description>Email address 4 (anchored; limit total length and length of each part)&#13;&#10;Use this anchored version to check whether a valid email address was entered when you cannot use procedural code to check the length of the input.&#13;&#10;This regex makes two passes over the string to enforce limits on the overall length of the email address as well as the length of each part.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com
the_total_length_of_an_email_address_is_limited@two-hundred-fifty-four-characters.because-the-SMTP-protocol-for-sending-email.does-not-support-more-than-that.really-hard-to-come-up-with-a-bogus-address-as-long-as-this.still-not-long-enough.too-long-now.com]]></teststring>
		</action>
		<action id="Emailaddress4limittotallengthandlengthofeachpart" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?=[A-Z0-9][A-Z0-9@._%+-]{5,253}$)[A-Z0-9._%+-]{1,64}@(?:[A-Z0-9-]{1,63}\.)+[A-Z]{2,63}\b</regex>
			<description>Email address 4 (limit total length and length of each part)&#13;&#10;Use this version to seek out email addresses in random documents and texts.&#13;&#10;Improves on the original email address regex by excluding addresses with consecutive, limiting the length of each part, and limiting the length of the overall email address.&#13;&#10;Does not match email addresses using an IP address instead of a domain name.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com
the_total_length_of_an_email_address_is_limited@two-hundred-fifty-four-characters.because-the-SMTP-protocol-for-sending-email.does-not-support-more-than-that.really-hard-to-come-up-with-a-bogus-address-as-long-as-this.still-not-long-enough.too-long-now.com]]></teststring>
		</action>
		<action id="EmailaddressReplacewithHTMLlink" purpose="replace" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:mailto:)?([A-Z0-9._%+-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,})\b</regex>
			<replace>&lt;a href="mailto:$1">$0&lt;/a></replace>
			<description>Email address: Replace with HTML link</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
]]></teststring>
		</action>
		<action id="EmailaddressRFC5322" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>csharp20</builtin>
			</flavor>
			<regex>\A&#13;&#10;(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*&#13;&#10;|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]&#13;&#10;|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")&#13;&#10;@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?&#13;&#10;|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}&#13;&#10;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:&#13;&#10;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]&#13;&#10;|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)&#13;&#10;\])&#13;&#10;\z</regex>
			<replace>xxx</replace>
			<description>Email address: RFC 5322&#13;&#10;This regular expression implements the official RFC 5322 standard for email addresses, restricting the domain part to the recommendation in RFC 1035.  Does NOT enforce any maximum lengths because the syntax specifications in these RFCs do not do so.  Using this regular expression in actual applications is NOT recommended.  It is shown to illustrate that with regular expressions there's always a trade-off between what's exact and what's practical.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com
the_total_length_of_an_email_address_is_limited@two-hundred-fifty-four-characters.because-the-SMTP-protocol-for-sending-email.does-not-support-more-than-that.really-hard-to-come-up-with-a-bogus-address-as-long-as-this.still-not-long-enough.too-long-now.com]]></teststring>
		</action>
		<action id="EmailaddressRFC5322simplified" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>csharp20</builtin>
			</flavor>
			<regex>\A[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*&#13;&#10;@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\z</regex>
			<replace>xxx</replace>
			<description>Email address: RFC 5322 (simplified)&#13;&#10;Matches a normal email address, implementing the most commonly used address form from RFC 5322 with the domain name recommendation form RFC 1035.  Does NOT enforce any maximum lengths because the syntax specifications in these RFCs do not do so.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com
the_total_length_of_an_email_address_is_limited@two-hundred-fifty-four-characters.because-the-SMTP-protocol-for-sending-email.does-not-support-more-than-that.really-hard-to-come-up-with-a-bogus-address-as-long-as-this.still-not-long-enough.too-long-now.com]]></teststring>
		</action>
		<action id="EmailaddressRFC5322simplifiedlimitlengths" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>csharp20</builtin>
			</flavor>
			<regex>\A(?=[a-z0-9@.!#$%&amp;'*+/=?^_`{|}~-]{6,254}\z)&#13;&#10;  (?=[a-z0-9.!#$%&amp;'*+/=?^_`{|}~-]{1,64}@)[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*&#13;&#10;@ (?:(?=[a-z0-9-]{1,63}\.)[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+&#13;&#10;  (?=[a-z0-9-]{1,63}\z)[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\z</regex>
			<replace>xxx</replace>
			<description>Email address: RFC 5322 (simplified; limit lengths)&#13;&#10;Matches a normal email address, implementing the most commonly used address form from RFC 5322 with the domain name recommendation form RFC 1035.  Adds length limitations specified in comments in these RFCs and imposed by actual email systems.&#13;&#10;Requires the "case insensitive" option to be ON.</description>
			<teststring><![CDATA[Valid addresses:
================
president@whitehouse.gov
ip@1.2.3.123
pharaoh@egyptian.museum
john.doe+regexbuddy@gmail.com
Mike.O'Dell@ireland.com
"Mike\ O'Dell"@ireland.com
IPguy@[1.2.3.4]
The email address president@whitehouse.gov is valid.
fabio@disapproved.solutions has a long TLD
fabio@email.validating.solutions

Invalid addresses:
==================
1024x768@60Hz
not.a.valid.email
invalid@ifon.nonexistingtld
john@aol...com
Mike\ O'Dell@ireland.com
joe@ha!ha!.com
joe@a_domain_name_with_more_than_sixty-four_characters_is_invalid_6465.com
a_local_part_with_more_than_sixty-four_characters_is_invalid_6465@mail.com
the_total_length_of_an_email_address_is_limited@two-hundred-fifty-four-characters.because-the-SMTP-protocol-for-sending-email.does-not-support-more-than-that.really-hard-to-come-up-with-a-bogus-address-as-long-as-this.still-not-long-enough.too-long-now.com]]></teststring>
		</action>
		<action id="HTMLcomment" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;!--.*?--></regex>
			<description>HTML comment</description>
			<teststring><![CDATA[<html>
<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>First paragraph</p>
<p><a href="http://www.regexbuddy.com/">Link</a> paragraph</p>
<!--More boring stuff omitted-->
</body>
</html>]]></teststring>
		</action>
		<action id="HTMLfile" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;html>.*?&lt;head>.*?&lt;title>.*?&lt;/title>.*?&lt;/head>.*?&lt;body[^>]*>.*?&lt;/body>.*?&lt;/html></regex>
			<description>HTML file&#13;&#10;Matches a complete HTML file.  Place round brackets around the .*? parts you want to extract from the file.&#13;&#10;Performance will be terrible on HTML files that miss some of the tags (and thus won't be matched by this regular expression).  Use the atomic version instead when your search includes such files (the atomic version will also fail invalid files, but much faster).</description>
			<teststring><![CDATA[<html>
<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>First paragraph</p>
<p><a href="http://www.regexbuddy.com/">Link</a> paragraph</p>
<!--More boring stuff omitted-->
</body>
</html>]]></teststring>
		</action>
		<action id="HTMLfileatomic" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;html>(?>.*?&lt;head>)(?>.*?&lt;title>)(?>.*?&lt;/title>)(?>.*?&lt;/head>)(?>.*?&lt;body[^>]*>)(?>.*?&lt;/body>).*?&lt;/html></regex>
			<description>HTML file (atomic)&#13;&#10;Matches a complete HTML file.  Place round brackets around the .*? parts you want to extract from the file.&#13;&#10;Atomic grouping maintains the regular expression's performance on invalid HTML files.</description>
			<teststring><![CDATA[<html>
<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>First paragraph</p>
<p><a href="http://www.regexbuddy.com/">Link</a> paragraph</p>
<!--More boring stuff omitted-->
</body>
</html>]]></teststring>
		</action>
		<action id="HTMLtaganyemptypair" caseless="1" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;([A-Z][A-Z0-9]*)\b[^>]*>\s*&lt;/\1></regex>
			<description>HTML tag (any empty pair)&#13;&#10;Matches the opening and closing pair of an HTML tag, with nothing or only whitespace between the tags.&#13;&#10;The name of the tag is stored into the first capturing group.</description>
			<teststring><![CDATA[<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>Empty tag goes here: <b></b></p>
<p>Just whitespace: <i> </i></p>
<p>Empty paragraph:</p>
<p>
</p>
<!--More boring stuff omitted-->
</body>
]]></teststring>
		</action>
		<action id="HTMLtaganypair" caseless="1" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;([A-Z][A-Z0-9]*)\b[^>]*>(.*?)&lt;/\1></regex>
			<description>HTML tag (any pair)&#13;&#10;Matches the opening and closing pair of whichever HTML tag comes next.&#13;&#10;The name of the tag is stored into the first capturing group.&#13;&#10;The text between the tags is stored into the second capturing group.</description>
			<teststring><![CDATA[<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>First paragraph</p>
<!--More boring stuff omitted-->
</body>
]]></teststring>
		</action>
		<action id="HTMLtagany" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;/?[a-z][a-z0-9]*[^&lt;>]*></regex>
			<description>HTML tag (any)&#13;&#10;Matches any opening or closing HTML tag, without its contents.</description>
			<teststring><![CDATA[<html>
<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>First paragraph</p>
<p><a href="http://www.regexbuddy.com/">Link</a> paragraph</p>
<!--More boring stuff omitted-->
</body>
</html>]]></teststring>
		</action>
		<action id="HTMLtagspecificpair" caseless="1" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;%TAG%\b[^>]*>(.*?)&lt;/%TAG%></regex>
			<description>HTML tag (specific pair)&#13;&#10;Matches the opening and closing pair of a specific HTML tag.&#13;&#10;Anything between the tags is stored into the first capturing group.&#13;&#10;Does NOT properly match tags nested inside themselves.</description>
			<teststring><![CDATA[<html>
<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>First paragraph</p>
<!--More boring stuff omitted-->
</body>
</html>]]></teststring>
			<parameter description="The HTML tag you want to match" defaultvalue="HTML">%TAG%</parameter>
		</action>
		<action id="HTMLtagmissingclosingtag" caseless="1" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?>&lt;%TAG%\b.*?(?=&lt;%TAG%\b|&lt;/%TAG%>|\z))(?!&lt;/%TAG%>)</regex>
			<description>HTML tag missing closing tag&#13;&#10;Matches an HTML &lt;tag> and all the text that follows it until the next identical tag or the end of the file if the closing &lt;/tag> is missing.  Tags cannot be nested.</description>
			<parameter description="The tag you want to find missing closing tags for" defaultvalue="p">%TAG%</parameter>
		</action>
		<action id="HTMLtaginsertclosingtag" purpose="replace" caseless="1" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?>&lt;%TAG%\b.*?(?=&lt;%TAG%\b|&lt;/%TAG%>|\z))(?!&lt;/%TAG%>)</regex>
			<replace>$0&lt;/%TAG%></replace>
			<description>HTML tag: insert closing tag&#13;&#10;Matches an HTML &lt;tag> and all the text that follows it until the next identical tag or the end of the file if the closing &lt;/tag> is missing.  Reinserts the match and the closing tag upon replace.&#13;&#10;&#13;&#10;If the tag is nested within other tags, you'll need to add their closing tags as additional alternation options inside the lookahead</description>
			<parameter description="The tag you want to find missing closing tags for" defaultvalue="p">%TAG%</parameter>
		</action>
		<action id="HTMLStripHTMLtags" purpose="replace" caseless="1" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;(style|script)[^&lt;>]*>.*?&lt;/\1>|&lt;/?[a-z][a-z0-9]*[^&lt;>]*>|&lt;!--.*?--></regex>
			<description>HTML: Strip HTML tags</description>
		</action>
		<action id="HTMLStripHTMLtagsandscripts" purpose="replace" caseless="1" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;/?[a-z][a-z0-9]*[^&lt;>]*>|&lt;!--.*?--></regex>
			<description>HTML: Strip HTML tags and scripts&#13;&#10;Removes all HTML tags, HTML comments, and script and style tags along with their contents.</description>
			<teststring><![CDATA[<html>
<head>
<title>This is a test</title>
</head>
<body bgcolor=white>
<h1>This is a test</h1>
<p>First paragraph</p>
<p><a href="http://www.regexbuddy.com/">Link</a> paragraph</p>
<!--More boring stuff omitted-->
</body>
</html>]]></teststring>
		</action>
		<action id="INIItemandvaluepair" multiline="1">
			<flavor>
				<builtin>msie</builtin>
			</flavor>
			<regex>^([^=\r\n]+)=(.*)</regex>
			<replace>repl</replace>
			<description>INI: Item and value pair</description>
			<teststring><![CDATA[[Section1]
Item1=Value1
Item2=Value2

[Section2]
Item3=Value3
Item4=Value4

]]></teststring>
		</action>
		<action id="INISectionblock" multiline="1">
			<flavor>
				<builtin>msie</builtin>
			</flavor>
			<regex>\[[^\]\r\n]+](?:\r?\n(?:[^[\r\n].*)?)*</regex>
			<replace>repl</replace>
			<description>INI: Section block</description>
			<teststring><![CDATA[[Section1]
Item1=Value1
Item2=Value2

[Section2]
Item3=Value3

Item4=Value4
[Section3]
Item5=Value5
]]></teststring>
		</action>
		<action id="INISectionheader" multiline="1">
			<flavor>
				<builtin>msie</builtin>
			</flavor>
			<regex>\[[^\]\r\n]+]</regex>
			<replace>repl</replace>
			<description>INI: Section header</description>
			<teststring><![CDATA[[Section1]
Item1=Value1
Item2=Value2

[Section2]
Item3=Value3
Item4=Value4

]]></teststring>
		</action>
		<action id="IPv4addressaccuratecapture">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b</regex>
			<description>IPv4 address (accurate capture)&#13;&#10;Matches 0.0.0.0 through 255.255.255.255&#13;&#10;Use this regex to match IP numbers with accurracy.&#13;&#10;Each of the 4 numbers is stored into a capturing group, so you can access them for further processing.</description>
			<teststring><![CDATA[Valid IP addresses
1.2.3.4
255.255.255.255

Invalid IP addresses
1.2.3
1.2.3.
.1.2.3
1.2.3.4.5.6.7.8 (use anchors ^ and $ to skip these if needed)
999.999.999.999 (use a complex regex to skip these if needed)
299.299.299.299
001.002.003.004 (these use octal notation, not decimal)
]]></teststring>
		</action>
		<action id="IPv4addressaccuratecaptureanchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</regex>
			<description>IPv4 address (accurate capture, anchored)&#13;&#10;Matches 0.0.0.0 through 255.255.255.255&#13;&#10;Use this regex to match IP numbers with accurracy.&#13;&#10;Each of the 4 numbers is stored into a capturing group, so you can access them for further processing.</description>
			<teststring><![CDATA[Valid IP addresses
1.2.3.4
255.255.255.255

Invalid IP addresses
1.2.3
1.2.3.
.1.2.3
1.2.3.4.5.6.7.8 (use anchors ^ and $ to skip these if needed)
999.999.999.999 (use a complex regex to skip these if needed)
299.299.299.299
001.002.003.004 (these use octal notation, not decimal)
]]></teststring>
		</action>
		<action id="IPv4addressaccurate">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b</regex>
			<description>IPv4 address (accurate)&#13;&#10;Matches 0.0.0.0 through 255.255.255.255&#13;&#10;Use this regex to match IP numbers with accurracy, without access to the individual IP numbers.</description>
			<teststring><![CDATA[Valid IP addresses
1.2.3.4
255.255.255.255

Invalid IP addresses
1.2.3
1.2.3.
.1.2.3
1.2.3.4.5.6.7.8 (use anchors ^ and $ to skip these if needed)
999.999.999.999 (use a complex regex to skip these if needed)
299.299.299.299
001.002.003.004 (these use octal notation, not decimal)
]]></teststring>
		</action>
		<action id="IPv4addressaccurateanchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</regex>
			<description>IPv4 address (accurate, anchored)&#13;&#10;Matches 0.0.0.0 through 255.255.255.255&#13;&#10;Use this regex to match IP numbers with accurracy, without access to the individual IP numbers.</description>
			<teststring><![CDATA[Valid IP addresses
1.2.3.4
255.255.255.255

Invalid IP addresses
1.2.3
1.2.3.
.1.2.3
1.2.3.4.5.6.7.8 (use anchors ^ and $ to skip these if needed)
999.999.999.999 (use a complex regex to skip these if needed)
299.299.299.299
001.002.003.004 (these use octal notation, not decimal)
]]></teststring>
		</action>
		<action id="IPv4addresssimplecapture">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\b</regex>
			<description>IPv4 address (simple capture)&#13;&#10;Matches 0.0.0.0 through 999.999.999.999&#13;&#10;Use this fast and simple regex if you know the data does not contain invalid IP addresses.&#13;&#10;Each of the 4 numbers is stored into a capturing group, so you can access them for further processing.</description>
			<teststring><![CDATA[Valid IP addresses
1.2.3.4
001.002.003.004
255.255.255.255

Invalid IP addresses
1.2.3
1.2.3.
.1.2.3
1.2.3.4.5.6.7.8 (use anchors ^ and $ to skip these if needed)
999.999.999.999 (use a complex regex to skip these if needed)
299.299.299.299]]></teststring>
		</action>
		<action id="IPv4addresssimple">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b</regex>
			<description>IPv4 address (simple)&#13;&#10;Matches 0.0.0.0 through 999.999.999.999&#13;&#10;Use this fast and simple regex if you know the data does not contain invalid IP addresses, and you don't need access to the individual IP numbers.</description>
			<teststring><![CDATA[Valid IP addresses
1.2.3.4
001.002.003.004
255.255.255.255

Invalid IP addresses
1.2.3
1.2.3.
.1.2.3
1.2.3.4.5.6.7.8 (use anchors ^ and $ to skip these if needed)
999.999.999.999 (use a complex regex to skip these if needed)
299.299.299.299]]></teststring>
		</action>
		<action id="IPv6addresscompressedandcompressedmixed" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![:.\w])(?:                                         # Anchor address&#13;&#10; (?:  # Mixed&#13;&#10;  (?:[A-F0-9]{1,4}:){6}                                # Non-compressed&#13;&#10; |(?=(?:[A-F0-9]{0,4}:){2,6}                           # Compressed with 2 to 6 colons&#13;&#10;     (?:[0-9]{1,3}\.){3}[0-9]{1,3}                     #    and 4 bytes&#13;&#10;     (?![:.\w]))                                       #    and anchored&#13;&#10;  (([0-9A-F]{1,4}:){1,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)  #    and at most 1 double colon&#13;&#10; |::(?:[A-F0-9]{1,4}:){5}                              # Compressed with 7 colons and 5 numbers&#13;&#10; )&#13;&#10; (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # 255.255.255.&#13;&#10; (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])           # 255&#13;&#10;|     # Standard&#13;&#10; (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}                    # Standard&#13;&#10;|     # Compressed&#13;&#10; (?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}               # Compressed with at most 7 colons&#13;&#10;    (?![:.\w]))                                        #    and anchored&#13;&#10; (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)    #    and at most 1 double colon&#13;&#10;|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}           # Compressed with 8 colons&#13;&#10;)(?![:.\w])                                            # Anchor address</regex>
			<description>IPv6 address (compressed and compressed mixed)&#13;&#10;8 hexadecimal words, or 6 hexadecimal words followed by 4 decimal bytes&#13;&#10;All with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressedandcompressedmixedanchored" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A(?:                                                  # Anchor address&#13;&#10; (?:  # Mixed&#13;&#10;  (?:[A-F0-9]{1,4}:){6}                                # Non-compressed&#13;&#10; |(?=(?:[A-F0-9]{0,4}:){2,6}                           # Compressed with 2 to 6 colons&#13;&#10;     (?:[0-9]{1,3}\.){3}[0-9]{1,3}                     #    and 4 bytes&#13;&#10;     \z)                                               #    and anchored&#13;&#10;  (([0-9A-F]{1,4}:){1,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)  #    and at most 1 double colon&#13;&#10; |::(?:[A-F0-9]{1,4}:){5}                              # Compressed with 7 colons and 5 numbers&#13;&#10; )&#13;&#10; (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # 255.255.255.&#13;&#10; (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])           # 255&#13;&#10;|     # Standard&#13;&#10; (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}                    # Standard&#13;&#10;|     # Compressed&#13;&#10; (?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}               # Compressed with at most 7 colons&#13;&#10;    \z)                                                #    and anchored&#13;&#10; (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)    #    and at most 1 double colon&#13;&#10;|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}           # Compressed with 8 colons&#13;&#10;)\z                                                    # Anchor address</regex>
			<description>IPv6 address (compressed and compressed mixed, anchored)&#13;&#10;8 hexadecimal words, or 6 hexadecimal words followed by 4 decimal bytes&#13;&#10;All with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressedandcompressedmixednolookaround" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:                                            # Anchor address&#13;&#10;(?:  # Compressed mixed&#13;&#10;  (?:[A-F0-9]{1,4}:){5}[A-F0-9]{1,4}               # No ::&#13;&#10;| (?:[A-F0-9]{1,4}:){4}:[A-F0-9]{1,4}              # 4::1&#13;&#10;| (?:[A-F0-9]{1,4}:){3}(?::[A-F0-9]{1,4}){1,2}     # 3::2&#13;&#10;| (?:[A-F0-9]{1,4}:){2}(?::[A-F0-9]{1,4}){1,3}     # 2::3&#13;&#10;| [A-F0-9]{1,4}:(?::[A-F0-9]{1,4}){1,4}            # 1::4&#13;&#10;| (?:[A-F0-9]{1,4}:){1,5}                          # :: at the end&#13;&#10;| :(?::[A-F0-9]{1,4}){1,5}                         # :: at the start&#13;&#10;| :                                                # Only ::&#13;&#10;) :&#13;&#10;(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # 255.255.255.&#13;&#10;(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])           # 255&#13;&#10;| # Compressed&#13;&#10;  (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}            # No ::&#13;&#10;| (?:[A-F0-9]{1,4}:){6}:[A-F0-9]{1,4}           # 6::1&#13;&#10;| (?:[A-F0-9]{1,4}:){5}(?::[A-F0-9]{1,4}){1,2}  # 5::2&#13;&#10;| (?:[A-F0-9]{1,4}:){4}(?::[A-F0-9]{1,4}){1,3}  # 4::3&#13;&#10;| (?:[A-F0-9]{1,4}:){3}(?::[A-F0-9]{1,4}){1,4}  # 3::4&#13;&#10;| (?:[A-F0-9]{1,4}:){2}(?::[A-F0-9]{1,4}){1,5}  # 2::5&#13;&#10;| [A-F0-9]{1,4}:(?::[A-F0-9]{1,4}){1,6}         # 1::6&#13;&#10;| (?:[A-F0-9]{1,4}:){1,7}:                      # :: at the end&#13;&#10;| :(?::[A-F0-9]{1,4}){1,7}                      # :: at the start&#13;&#10;| ::                                            # Only ::&#13;&#10;)$                                              # Anchor address</regex>
			<description>IPv6 address (compressed and compressed mixed, no lookaround)&#13;&#10;8 hexadecimal words, or 6 hexadecimal words followed by 4 decimal bytes&#13;&#10;All with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::&#13;&#10;This regex doesn't use lookaround, so it works with flavors that don't support this feature</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressedmixed" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![:.\w])                                           # Anchor address&#13;&#10;(?:&#13;&#10; (?:[A-F0-9]{1,4}:){6}                                # Non-compressed&#13;&#10;|(?=(?:[A-F0-9]{0,4}:){2,6}                           # Compressed with 2 to 6 colons&#13;&#10;    (?:[0-9]{1,3}\.){3}[0-9]{1,3}                     #    and 4 bytes&#13;&#10;    (?![:.\w]))                                       #    and anchored&#13;&#10; (([0-9A-F]{1,4}:){1,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)  #    and at most 1 double colon&#13;&#10;|::(?:[A-F0-9]{1,4}:){5}                              # Compressed with 7 colons and 5 numbers&#13;&#10;)&#13;&#10;(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # 255.255.255.&#13;&#10;(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])           # 255&#13;&#10;(?![:.\w])                                            # Anchor address</regex>
			<description>IPv6 address (compressed mixed)&#13;&#10;6 hexadecimal words, followed by 4 decimal bytes, all with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::&#13;&#10;</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressedmixedanchored" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A                                                    # Anchor address&#13;&#10;(?:&#13;&#10; (?:[A-F0-9]{1,4}:){6}                                # Non-compressed&#13;&#10;|(?=(?:[A-F0-9]{0,4}:){2,6}                           # Compressed with 2 to 6 colons&#13;&#10;    (?:[0-9]{1,3}\.){3}[0-9]{1,3}                     #    and 4 bytes&#13;&#10;    \z)                                               #    and anchored&#13;&#10; (([0-9A-F]{1,4}:){1,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)  #    and at most 1 double colon&#13;&#10;|::(?:[A-F0-9]{1,4}:){5}                              # Compressed with 7 colons and 5 numbers&#13;&#10;)&#13;&#10;(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # 255.255.255.&#13;&#10;(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])           # 255&#13;&#10;\z                                                    # Anchor address</regex>
			<description>IPv6 address (compressed mixed, anchored)&#13;&#10;6 hexadecimal words, followed by 4 decimal bytes, all with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::&#13;&#10;</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressedmixednolookaround" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A                                                 # Anchor address&#13;&#10;(?:&#13;&#10;  (?:[A-F0-9]{1,4}:){5}[A-F0-9]{1,4}               # No ::&#13;&#10;| (?:[A-F0-9]{1,4}:){4}:[A-F0-9]{1,4}              # 4::1&#13;&#10;| (?:[A-F0-9]{1,4}:){3}(?::[A-F0-9]{1,4}){1,2}     # 3::2&#13;&#10;| (?:[A-F0-9]{1,4}:){2}(?::[A-F0-9]{1,4}){1,3}     # 2::3&#13;&#10;| [A-F0-9]{1,4}:(?::[A-F0-9]{1,4}){1,4}            # 1::4&#13;&#10;| (?:[A-F0-9]{1,4}:){1,5}                          # :: at the end&#13;&#10;| :(?::[A-F0-9]{1,4}){1,5}                         # :: at the start&#13;&#10;| :                                                # Only ::&#13;&#10;) :&#13;&#10;(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # 255.255.255.&#13;&#10;(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])           # 255&#13;&#10;\z                                                 # Anchor address</regex>
			<description>IPv6 address (compressed mixed, no lookaround)&#13;&#10;6 hexadecimal words, followed by 4 decimal bytes, all with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::&#13;&#10;This regex doesn't use lookaround, so it works with flavors that don't support this feature</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressed" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![:.\w])(?:                                        # Anchor address&#13;&#10; (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}                   # Standard&#13;&#10;|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}              # Compressed with at most 7 colons&#13;&#10;    $)                                                #    and anchored&#13;&#10; (([A-F0-9]{1,4}:){1,7}|:)((:[A-F0-9]{1,4}){1,7}|:)   #    and at most 1 double colon&#13;&#10;|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}          # Compressed with 8 colons&#13;&#10;)(?![:.\w])                                           # Anchor address</regex>
			<description>IPv6 address (compressed)&#13;&#10;8 hexadecimal words, with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressedanchored" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A(?:                                                 # Anchor address&#13;&#10; (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}                   # Standard&#13;&#10;|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}              # Compressed with at most 7 colons&#13;&#10;    \z)                                               #    and anchored&#13;&#10; (([A-F0-9]{1,4}:){1,7}|:)((:[A-F0-9]{1,4}){1,7}|:)   #    and at most 1 double colon&#13;&#10;|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}          # Compressed with 8 colons&#13;&#10;)\z                                                   # Anchor address</regex>
			<description>IPv6 address (compressed, anchored)&#13;&#10;8 hexadecimal words, with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addresscompressednolookaround" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A(?:                                           # Anchor address&#13;&#10;  (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}            # No ::&#13;&#10;| (?:[A-F0-9]{1,4}:){6}:[A-F0-9]{1,4}           # 6::1&#13;&#10;| (?:[A-F0-9]{1,4}:){5}(?::[A-F0-9]{1,4}){1,2}  # 5::2&#13;&#10;| (?:[A-F0-9]{1,4}:){4}(?::[A-F0-9]{1,4}){1,3}  # 4::3&#13;&#10;| (?:[A-F0-9]{1,4}:){3}(?::[A-F0-9]{1,4}){1,4}  # 3::4&#13;&#10;| (?:[A-F0-9]{1,4}:){2}(?::[A-F0-9]{1,4}){1,5}  # 2::5&#13;&#10;| [A-F0-9]{1,4}:(?::[A-F0-9]{1,4}){1,6}         # 1::6&#13;&#10;| (?:[A-F0-9]{1,4}:){1,7}:                      # :: at the end&#13;&#10;| :(?::[A-F0-9]{1,4}){1,7}                      # :: at the start&#13;&#10;| ::                                            # Only ::&#13;&#10;)\z                                             # Anchor address</regex>
			<description>IPv6 address (compressed, no lookaround)&#13;&#10;8 hexadecimal words, with optional leading zeros&#13;&#10;Consecutive zeros may be replaced with ::&#13;&#10;This regex doesn't use lookaround, so it works with flavors that don't support this feature</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addressmixed" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![:.\w])(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?![:.\w])</regex>
			<description>IPv6 address (mixed)&#13;&#10;6 hexadecimal words, followed by 4 decimal bytes, all with optional leading zeros</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addressmixedanchored" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\z</regex>
			<description>IPv6 address (mixed, anchored)&#13;&#10;6 hexadecimal words, followed by 4 decimal bytes, all with optional leading zeros&#13;&#10;This regex doesn't use lookaround, so it works with flavors that don't support this feature</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addressstandardandmixed" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![:.\w])                                           # Anchor address&#13;&#10;(?:[A-F0-9]{1,4}:){6}                                 # 6 words&#13;&#10;(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words&#13;&#10;|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes&#13;&#10;   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])&#13;&#10;)(?![:.\w])                                           # Anchor address</regex>
			<description>IPv6 address (standard and mixed)&#13;&#10;8 hexadecimal words, or 6 hexadecimal words followed by 4 decimal bytes&#13;&#10;All with optional leading zeros</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addressstandardandmixedanchored" caseless="1" freespacing="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A                                                    # Anchor address&#13;&#10;(?:[A-F0-9]{1,4}:){6}                                 # 6 words&#13;&#10;(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words&#13;&#10;|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes&#13;&#10;   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])&#13;&#10;)\z                                                   # Anchor address</regex>
			<description>IPv6 address (standard and mixed, anchored)&#13;&#10;8 hexadecimal words, or 6 hexadecimal words followed by 4 decimal bytes&#13;&#10;All with optional leading zeros&#13;&#10;This regex doesn't use lookaround, so it works with flavors that don't support this feature</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addressstandard" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![:.\w])(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}(?![:.\w])</regex>
			<description>IPv6 address (standard)&#13;&#10;8 hexadecimal words, with optional leading zeros</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="IPv6addressstandardanchored" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}\z</regex>
			<description>IPv6 address (standard, anchored)&#13;&#10;8 hexadecimal words, with optional leading zeros&#13;&#10;This regex doesn't use lookaround, so it works with flavors that don't support this feature</description>
			<teststring><![CDATA[1762:0:0:0:0:B03:1:AF18
FF01:0:0:0:CA:0:0:2
0:0:0:0:0:0:0:1
0:0:0:0:0:0:0:0
1762::B03:1:AF18
FF01:7:CA:0::
::FF01:7:CA:0
::1
1::
::1:2:3:4:5:6:7
1:2:3:4:5:6:7::
0:0:0:0:0:0:127.32.67.15
0:0:0:0:0:FFFF:127.32.67.15
::127.32.67.15
::FFFF:127.32.67.15
FFFF::127.32.67.15
::1:2:3:4:5:127.32.67.15

:127.32.67.15
:1234:127.32.67.15
:1234:1234:1234
1234:1234:1234:
1234::234::234::2342
1234:1234:1234:1234:1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234:1234:1234
1234:1234:1234:1234::1234:1234:1234:1234:1234::1234:1234]]></teststring>
		</action>
		<action id="LinesAbsolutelyblanknowhitespace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^$</regex>
			<description>Lines: Absolutely blank (no whitespace)&#13;&#10;Regex match does not include line break after the line.</description>
			<teststring><![CDATA[blank

line
line with

four spaces]]></teststring>
		</action>
		<action id="LinesAppendsomethingtoeachline" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>$</regex>
			<replace>something</replace>
			<description>Lines: Append something to each line</description>
			<teststring><![CDATA[blank

line
line with

four spaces]]></teststring>
		</action>
		<action id="LinesBlankmaycontainwhitespace" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ \t]*$</regex>
			<description>Lines: Blank (may contain whitespace)&#13;&#10;Regex match does not include line break after the line.</description>
			<teststring><![CDATA[blank

line
line with

four spaces]]></teststring>
		</action>
		<action id="LinesCompletelinematchedbyseveralunrelatedregularexpressionsany" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?=.*?%ONE%)(?=.*?%TWO%).*$</regex>
			<description>Lines: Complete line matched by several unrelated regular expressions, anywhere on the line.&#13;&#10;&#13;&#10;Explanation: Right after the anchor, two sets of lookahead scan the entire line for a regular expression.  If one of the lookaheads fails, the overall match fails.  If all three succeed, the final .* matches the entire line.&#13;&#10;&#13;&#10;To add additional requirements, simply add additional lookaheads after the anchor.  For efficiency, specify them from least likely to match to most likely to match.  That allows the overall regex to fail faster.</description>
			<parameter description="First requirement" defaultvalue="one">%ONE%</parameter>
			<parameter description="Second requirement" defaultvalue="two">%TWO%</parameter>
		</action>
		<action id="LinesCompletelineNOTmatchedbytheregularexpressionREGEX" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:(?!%REGEX%).)*$\r?\n?</regex>
			<description>Lines: Complete line NOT matched by the regular expression %REGEX%&#13;&#10;&#13;&#10;Explanation: Observe that the negative lookahead and the dot are repeated together.  This makes sure we test that %REGEX% fails at EVERY position in the string, and not just at any particular position.&#13;&#10;&#13;&#10;Tip: use alternation in %REGEX% to match a line that does not meet any of several requirements.  E.g. set %REGEX% to "one|two" (without the quotes), and the overall regular expression will match any line that does not contain either (or both) "one" or "two".</description>
			<parameter description="The regular expression the line should NOT match" defaultvalue="%REGEX%">%REGEX%</parameter>
		</action>
		<action id="LinesCompletelinepartiallymatchedbyaregex" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^.*(%REGEX%).*$</regex>
			<description>Lines: Complete line partially matched by a regex&#13;&#10;Substitute %REGEX% with the regular expression you want to search for.  The overall regular expression will then completely match each line that is partially matched by the regular expression you substituted %REGEX% with.</description>
			<parameter description="The regular expression that should partially match the line" defaultvalue="regex">%REGEX%</parameter>
		</action>
		<action id="LinesCompletelineincludingterminatinglinebreakNOTmatchedbythere" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?:(?!%REGEX%).)*$</regex>
			<description>Lines: Complete line, including terminating line break, NOT matched by the regular expression %REGEX%&#13;&#10;&#13;&#10;Explanation: Observe that the negative lookahead and the dot are repeated together.  This makes sure we test that %REGEX% fails at EVERY position in the string, and not just at any particular position.&#13;&#10;&#13;&#10;Tip: use alternation in %REGEX% to match a line that does not meet any of several requirements.  E.g. set %REGEX% to "one|two" (without the quotes), and the overall regular expression will match any line that does not contain either (or both) "one" or "two".&#13;&#10;&#13;&#10;You could use this regex in a search-and-replace operation in a text editor to delete or substitute complete lines.</description>
			<parameter description="The regular expression the line should NOT match" defaultvalue="%REGEX%">%REGEX%</parameter>
		</action>
		<action id="LinesCompletelineincludingterminatinglinebreakpartiallymatchedb" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^.*(%REGEX%).*$\r?\n?</regex>
			<description>Lines: Complete line, including terminating line break, partially matched by a regex&#13;&#10;Substitute %REGEX% with the regular expression you want to search for.  The overall regular expression will then completely match each line that is partially matched by the regular expression you substituted %REGEX% with.&#13;&#10;&#13;&#10;You could use this regex in a search-and-replace operation in a text editor to delete or substitute complete lines.</description>
			<parameter description="The regular expression that should partially match the line" defaultvalue="regex">%REGEX%</parameter>
		</action>
		<action id="LinesDeleteabsolutelyblanklines" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^\r?\n</regex>
			<description>Lines: Delete absolutely blank lines&#13;&#10;Regex match includes line break after the line.</description>
			<teststring><![CDATA[blank

line
line with

four spaces]]></teststring>
		</action>
		<action id="LinesDeleteadjacentduplicatelines" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(.*)(\r?\n\1)+$</regex>
			<replace>$1</replace>
			<description>Lines: Delete adjacent duplicate lines&#13;&#10;This regex matches two or more lines, each identical to the first line.  It deletes all of them, except the first.</description>
			<teststring><![CDATA[one
two
two
three
three
three
four]]></teststring>
		</action>
		<action id="LinesDeleteblanklines" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ \t]*$\r?\n</regex>
			<description>Lines: Delete blank lines&#13;&#10;Regex match includes line break after the line.</description>
			<teststring><![CDATA[blank

line
line with

four spaces]]></teststring>
		</action>
		<action id="LinesDeleteduplicatelinesanywhere" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(.++)\r?\n(?=(?:^(?!\1$).*+\r?\n)*+\1$)</regex>
			<description>Lines: Delete duplicate lines anywhere&#13;&#10;This regex matches a line if a duplicate of that line follows it, even if there are other lines between the matched line and the duplicate.  Replacing all matches of this regex with nothing deletes all duplicate lines even if they are not adjacent.</description>
			<teststring><![CDATA[one
two
three
four
two
three
four
three
four
four]]></teststring>
		</action>
		<action id="LinesDuplicatelines" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(.*)(\r?\n\1)+$</regex>
			<description>Lines: Duplicate lines&#13;&#10;This regex matches two or more lines, each identical to the first line.</description>
			<teststring><![CDATA[one
two
two
three
three
three
four]]></teststring>
		</action>
		<action id="LinesPrependsomethingtoeachline" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^</regex>
			<replace>something</replace>
			<description>Lines: Prepend something to each line</description>
			<teststring><![CDATA[blank

line
line with

four spaces]]></teststring>
		</action>
		<action id="LinesTruncatealineafteraregexmatch" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(.*)(%REGEX%).*$</regex>
			<replace>$1$2</replace>
			<description>Lines: Truncate a line after a regex match.&#13;&#10;The regex you specify is guaranteed to match only once on each line.  If the original regex you specified should match more than once, the line will be truncated after the last match.&#13;&#10;&#13;&#10;Explanation: This works because the first dot-star is greedy.  It will match the complete line, and then backtrack until %REGEX% can be matched.</description>
			<parameter description="The regular expression that should partially match the line" defaultvalue="%REGEX%">%REGEX%</parameter>
		</action>
		<action id="LinesTruncatealineafteraregexmatch" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(%REGEX%).*$</regex>
			<replace>$1</replace>
			<description>Lines: Truncate a line after a regex match.&#13;&#10;If the regex matches more than once on the same line, everything after the first match is deleted.</description>
			<parameter description="The regular expression that should partially match the line" defaultvalue="%REGEX%">%REGEX%</parameter>
		</action>
		<action id="LinesTruncatealinebeforearegexmatch" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^.*(%REGEX%)(.*)$</regex>
			<replace>$1$2</replace>
			<description>Lines: Truncate a line before a regex match.&#13;&#10;The regex you specify is guaranteed to match only once on each line.  If the original regex you specified should match more than once, the line will be truncated before the first match.</description>
			<parameter description="The regular expression that should partially match the line" defaultvalue="%REGEX%">%REGEX%</parameter>
		</action>
		<action id="LinesTruncatealinebeforearegexmatch" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^.*(%REGEX%)</regex>
			<replace>$1</replace>
			<description>Lines: Truncate a line before a regex match.&#13;&#10;If the regex matches more than once on the same line, everything before the last match is deleted.</description>
			<parameter description="The regular expression that should partially match the line" defaultvalue="%REGEX%">%REGEX%</parameter>
		</action>
		<action id="LinesTruncatealinebeforeandafteraregexmatch" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^.*(%REGEX%).*$</regex>
			<replace>$1</replace>
			<description>Lines: Truncate a line before and after a regex match.&#13;&#10;This will delete everything from the line not matched by the regular expression.</description>
			<parameter description="The regular expression that should partially match the line" defaultvalue="%REGEX%">%REGEX%</parameter>
		</action>
		<action id="LogsApachewebserver" multiline="1">
			<flavor>
				<builtin>pcre830</builtin>
			</flavor>
			<regex>^((?#client IP or domain name)\S+) ((?#basic authentication)\S+ \S+) \[((?#date and time)[^]]+)\] "(?:GET|POST|HEAD) ((?#file)[^ ?"]+)\??((?#parameters)[^ ?"]+)? HTTP/[0-9.]+" ((?#status code)[0-9]+) ((?#bytes transferred)[-0-9]+) "((?#referrer)[^"]*)" "((?#user agent)[^"]*)"$</regex>
			<description>Logs: Apache web server&#13;&#10;Matches any single line from Apache's access logs, capturing each item into a backreference.&#13;&#10;If you are not interested in certain items, change the capturing groups into non-capturing groups for efficiency.</description>
			<teststring><![CDATA[69.244.250.79 - - [01/Sep/2006:00:03:33 -0400] "GET /test.html HTTP/1.1" 200 11879 "http://www.google.com/search?hs=GBf&hl=en&lr=&client=firefox-a&rls=org.mozilla%3Aen-US%3Aofficial&q=test+regular+expression&btnG=Search" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /highlight.js HTTP/1.1" 200 832 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /screens/testwrong.png HTTP/1.1" 200 24962 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/literal.gif HTTP/1.1" 200 308 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/special.gif HTTP/1.1" 200 296 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/repeat.gif HTTP/1.1" 200 292 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /screens/testright.png HTTP/1.1" 200 12483 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /favicon.ico HTTP/1.1" 200 1406 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
59.162.218.129 - - [01/Sep/2006:05:14:27 -0400] "GET /_vti_inf.html HTTP/1.1" 404 8185 "-" "Mozilla/2.0 (compatible; MS FrontPage 4.0)"
]]></teststring>
		</action>
		<action id="LogsApachewebserver404" multiline="1">
			<flavor>
				<builtin>pcre830</builtin>
			</flavor>
			<regex>^((?#client IP or domain name)\S+) ((?#basic authentication)\S+ \S+) \[((?#date and time)[^]]+)\] "(?:GET|POST|HEAD) ((?#file)[^ ?"]+)\??((?#parameters)[^ ?"]+)? HTTP/[0-9.]+" (?#status code)404 ((?#bytes transferred)[-0-9]+) "((?#referrer)[^"]*)" "((?#user agent)[^"]*)"$</regex>
			<description>Logs: Apache web server (404)&#13;&#10;404 errors only</description>
			<teststring><![CDATA[69.244.250.79 - - [01/Sep/2006:00:03:33 -0400] "GET /test.html HTTP/1.1" 200 11879 "http://www.google.com/search?hs=GBf&hl=en&lr=&client=firefox-a&rls=org.mozilla%3Aen-US%3Aofficial&q=test+regular+expression&btnG=Search" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /highlight.js HTTP/1.1" 200 832 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /screens/testwrong.png HTTP/1.1" 200 24962 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/literal.gif HTTP/1.1" 200 308 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/special.gif HTTP/1.1" 200 296 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/repeat.gif HTTP/1.1" 200 292 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /screens/testright.png HTTP/1.1" 200 12483 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /favicon.ico HTTP/1.1" 200 1406 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
59.162.218.129 - - [01/Sep/2006:05:14:27 -0400] "GET /_vti_inf.html HTTP/1.1" 404 8185 "-" "Mozilla/2.0 (compatible; MS FrontPage 4.0)"
]]></teststring>
		</action>
		<action id="LogsApachewebserver404namedcapture" multiline="1">
			<flavor>
				<builtin>pcre830</builtin>
			</flavor>
			<regex>^(?&lt;client>\S+) (?&lt;auth>\S+ \S+) \[(?&lt;datetime>[^]]+)\] "(?:GET|POST|HEAD) (?&lt;file>[^ ?"]+)\??(?&lt;parameters>[^ ?"]+)? HTTP/[0-9.]+" 404 (?&lt;size>[-0-9]+) "(?&lt;referrer>[^"]*)" "(?&lt;useragent>[^"]*)"$</regex>
			<description>Logs: Apache web server (404, named capture)&#13;&#10;404 errors only&#13;&#10;Captures each item into a named capturing group.  Works as it is with .NET, and after conversion by RegexBuddy on the Use page with Python, PHP/preg and PCRE.</description>
			<teststring><![CDATA[69.244.250.79 - - [01/Sep/2006:00:03:33 -0400] "GET /test.html HTTP/1.1" 200 11879 "http://www.google.com/search?hs=GBf&hl=en&lr=&client=firefox-a&rls=org.mozilla%3Aen-US%3Aofficial&q=test+regular+expression&btnG=Search" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /highlight.js HTTP/1.1" 200 832 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /screens/testwrong.png HTTP/1.1" 200 24962 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/literal.gif HTTP/1.1" 200 308 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/special.gif HTTP/1.1" 200 296 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/repeat.gif HTTP/1.1" 200 292 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /screens/testright.png HTTP/1.1" 200 12483 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /favicon.ico HTTP/1.1" 200 1406 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
59.162.218.129 - - [01/Sep/2006:05:14:27 -0400] "GET /_vti_inf.html HTTP/1.1" 404 8185 "-" "Mozilla/2.0 (compatible; MS FrontPage 4.0)"
]]></teststring>
		</action>
		<action id="LogsApachewebserverHTMLfiles" multiline="1">
			<flavor>
				<builtin>pcre830</builtin>
			</flavor>
			<regex>^((?#client IP or domain name)\S+) ((?#basic authentication)\S+ \S+) \[((?#date and time)[^]]+)\] "(?:GET|POST|HEAD) ((?#file)/[^ ?"]+?\.html?)\??((?#parameters)[^ ?"]+)? HTTP/[0-9.]+" (?#status code)200 ((?#bytes transferred)[-0-9]+) "((?#referrer)[^"]*)" "((?#user agent)[^"]*)"$</regex>
			<description>Logs: Apache web server (HTML files)&#13;&#10;Successful hits to HTML files only.  Useful for counting the number of page views.&#13;&#10;When gathering statistics about user agents and referrers, it often makes sense to look at hits to HTML files only.</description>
			<teststring><![CDATA[69.244.250.79 - - [01/Sep/2006:00:03:33 -0400] "GET /test.html HTTP/1.1" 200 11879 "http://www.google.com/search?hs=GBf&hl=en&lr=&client=firefox-a&rls=org.mozilla%3Aen-US%3Aofficial&q=test+regular+expression&btnG=Search" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /highlight.js HTTP/1.1" 200 832 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /screens/testwrong.png HTTP/1.1" 200 24962 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/literal.gif HTTP/1.1" 200 308 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/special.gif HTTP/1.1" 200 296 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/repeat.gif HTTP/1.1" 200 292 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /screens/testright.png HTTP/1.1" 200 12483 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /favicon.ico HTTP/1.1" 200 1406 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
59.162.218.129 - - [01/Sep/2006:05:14:27 -0400] "GET /_vti_inf.html HTTP/1.1" 404 8185 "-" "Mozilla/2.0 (compatible; MS FrontPage 4.0)"
]]></teststring>
		</action>
		<action id="LogsApachewebserverHTMLfilesnamedcapture" multiline="1">
			<flavor>
				<builtin>pcre830</builtin>
			</flavor>
			<regex>^(?&lt;client>\S+) (?&lt;auth>\S+ \S+) \[(?&lt;datetime>[^]]+)\] "(?:GET|POST|HEAD) (?&lt;file>[^ ?"]+?\.html?)\??(?&lt;parameters>[^ ?"]+)? HTTP/[0-9.]+" (?&lt;status>200) (?&lt;size>[-0-9]+) "(?&lt;referrer>[^"]*)" "(?&lt;useragent>[^"]*)"$</regex>
			<description>Logs: Apache web server (HTML files, named capture)&#13;&#10;Successful hits to HTML files only.  Useful for counting the number of page views.&#13;&#10;When gathering statistics about user agents and referrers, it often makes sense to look at hits to HTML files only.&#13;&#10;Captures each item into a named capturing group.  Works as it is with .NET, and after conversion by RegexBuddy on the Use page with Python, PHP/preg and PCRE.</description>
			<teststring><![CDATA[69.244.250.79 - - [01/Sep/2006:00:03:33 -0400] "GET /test.html HTTP/1.1" 200 11879 "http://www.google.com/search?hs=GBf&hl=en&lr=&client=firefox-a&rls=org.mozilla%3Aen-US%3Aofficial&q=test+regular+expression&btnG=Search" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /highlight.js HTTP/1.1" 200 832 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /screens/testwrong.png HTTP/1.1" 200 24962 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/literal.gif HTTP/1.1" 200 308 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/special.gif HTTP/1.1" 200 296 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/repeat.gif HTTP/1.1" 200 292 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /screens/testright.png HTTP/1.1" 200 12483 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /favicon.ico HTTP/1.1" 200 1406 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
59.162.218.129 - - [01/Sep/2006:05:14:27 -0400] "GET /_vti_inf.html HTTP/1.1" 404 8185 "-" "Mozilla/2.0 (compatible; MS FrontPage 4.0)"
]]></teststring>
		</action>
		<action id="LogsApachewebservernamedcapture" multiline="1">
			<flavor>
				<builtin>pcre830</builtin>
			</flavor>
			<regex>^(?&lt;client>\S+) (?&lt;auth>\S+ \S+) \[(?&lt;datetime>[^]]+)\] "(?:GET|POST|HEAD) (?&lt;file>[^ ?"]+)\??(?&lt;parameters>[^ ?"]+)? HTTP/[0-9.]+" (?&lt;status>[0-9]+) (?&lt;size>[-0-9]+) "(?&lt;referrer>[^"]*)" "(?&lt;useragent>[^"]*)"$</regex>
			<description>Logs: Apache web server (named capture)&#13;&#10;Matches any single line from Apache's access logs, capturing each item into a named capturing group.  Works as it is with .NET, and after conversion by RegexBuddy on the Use page with Python, PHP/preg and PCRE.&#13;&#10;If you are not interested in certain items, change the capturing groups into non-capturing groups for efficiency.</description>
			<teststring><![CDATA[69.244.250.79 - - [01/Sep/2006:00:03:33 -0400] "GET /test.html HTTP/1.1" 200 11879 "http://www.google.com/search?hs=GBf&hl=en&lr=&client=firefox-a&rls=org.mozilla%3Aen-US%3Aofficial&q=test+regular+expression&btnG=Search" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /highlight.js HTTP/1.1" 200 832 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:34 -0400] "GET /screens/testwrong.png HTTP/1.1" 200 24962 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/literal.gif HTTP/1.1" 200 308 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/special.gif HTTP/1.1" 200 296 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /img/repeat.gif HTTP/1.1" 200 292 "http://www.jgsoft.com/jgsoft.css" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /screens/testright.png HTTP/1.1" 200 12483 "http://www.regexbuddy.com/test.html" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
69.244.250.79 - - [01/Sep/2006:00:03:35 -0400] "GET /favicon.ico HTTP/1.1" 200 1406 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"
59.162.218.129 - - [01/Sep/2006:05:14:27 -0400] "GET /_vti_inf.html HTTP/1.1" 404 8185 "-" "Mozilla/2.0 (compatible; MS FrontPage 4.0)"
]]></teststring>
		</action>
		<action id="MACaddress" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[0-9A-F]{2}([-:]?)(?:[0-9A-F]{2}\1){4}[0-9A-F]{2}\b</regex>
			<description>MAC address&#13;&#10;12-34-56-78-9A-BC or 12:34:56:78:9A:BC or 123456789ABC</description>
			<teststring><![CDATA[only digits
08-00-27-00-50-49
08:00:27:00:50:49
080027005049
upper case
A8-00-27-00-50-4F
A8:00:27:00:50:4F
A8002700504F
lower case
a8-00-27-00-50-4f
a8:00:27:00:50:4f
a8002700504f

Broken cases:
missing 1 special character
08-00-27-00-5049
08:00:27:00:5049
additional special character
08-00-27-00-50--49
08:00:27:00:50::49
0800270050-49
missing one non special character
08-00-27-00-50-4
08:00:27:00:50:4
08002700504
trailing characters
08-00-27-00-50-49-
08:00:27:00:50:49:
080027005049-
preceding characters
-08-00-27-00-50-49
:08:00:27:00:50:49
:080027005049]]></teststring>
		</action>
		<action id="MACaddressanchored" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[0-9A-F]{2}([-:]?)(?:[0-9A-F]{2}\1){4}[0-9A-F]{2}$</regex>
			<description>MAC address (anchored)&#13;&#10;12-34-56-78-9A-BC or 12:34:56:78:9A:BC or 123456789ABC&#13;&#10;Anchored to check whether the whole string consists of a MAC address</description>
			<teststring><![CDATA[only digits
08-00-27-00-50-49
08:00:27:00:50:49
080027005049
upper case
A8-00-27-00-50-4F
A8:00:27:00:50:4F
A8002700504F
lower case
a8-00-27-00-50-4f
a8:00:27:00:50:4f
a8002700504f

Broken cases:
missing 1 special character
08-00-27-00-5049
08:00:27:00:5049
additional special character
08-00-27-00-50--49
08:00:27:00:50::49
0800270050-49
missing one non special character
08-00-27-00-50-4
08:00:27:00:50:4
08002700504
trailing characters
08-00-27-00-50-49-
08:00:27:00:50:49:
080027005049-
preceding characters
-08-00-27-00-50-49
:08:00:27:00:50:49
:080027005049]]></teststring>
		</action>
		<action id="MACaddresscapturenumbers" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?&lt;one>[0-9A-F]{2})(?&lt;delimiter>[-:]?)(?&lt;two>[0-9A-F]{2})\k&lt;delimiter>(?&lt;three>[0-9A-F]{2})\k&lt;delimiter>(?&lt;four>[0-9A-F]{2})\k&lt;delimiter>(?&lt;five>[0-9A-F]{2})\k&lt;delimiter>(?&lt;six>[0-9A-F]{2})\b</regex>
			<description>MAC address (capture numbers)&#13;&#10;12-34-56-78-9A-BC or 12:34:56:78:9A:BC or 123456789ABC&#13;&#10;With capturing groups to get all 6 bytes separately</description>
			<teststring><![CDATA[only digits
08-00-27-00-50-49
08:00:27:00:50:49
080027005049
upper case
A8-00-27-00-50-4F
A8:00:27:00:50:4F
A8002700504F
lower case
a8-00-27-00-50-4f
a8:00:27:00:50:4f
a8002700504f

Broken cases:
missing 1 special character
08-00-27-00-5049
08:00:27:00:5049
additional special character
08-00-27-00-50--49
08:00:27:00:50::49
0800270050-49
missing one non special character
08-00-27-00-50-4
08:00:27:00:50:4
08002700504
trailing characters
08-00-27-00-50-49-
08:00:27:00:50:49:
080027005049-
preceding characters
-08-00-27-00-50-49
:08:00:27:00:50:49
:080027005049]]></teststring>
		</action>
		<action id="MACaddresscapturenumbersanchored" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(?&lt;one>[0-9A-F]{2})(?&lt;delimiter>[-:]?)(?&lt;two>[0-9A-F]{2})\k&lt;delimiter>(?&lt;three>[0-9A-F]{2})\k&lt;delimiter>(?&lt;four>[0-9A-F]{2})\k&lt;delimiter>(?&lt;five>[0-9A-F]{2})\k&lt;delimiter>(?&lt;six>[0-9A-F]{2})$</regex>
			<description>MAC address (capture numbers; anchored)&#13;&#10;12-34-56-78-9A-BC or 12:34:56:78:9A:BC or 123456789ABC&#13;&#10;Anchored to check whether the whole string consists of a MAC address&#13;&#10;With capturing groups to get all 6 bytes separately</description>
			<teststring><![CDATA[only digits
08-00-27-00-50-49
08:00:27:00:50:49
080027005049
upper case
A8-00-27-00-50-4F
A8:00:27:00:50:4F
A8002700504F
lower case
a8-00-27-00-50-4f
a8:00:27:00:50:4f
a8002700504f

Broken cases:
missing 1 special character
08-00-27-00-5049
08:00:27:00:5049
additional special character
08-00-27-00-50--49
08:00:27:00:50::49
0800270050-49
missing one non special character
08-00-27-00-50-4
08:00:27:00:50:4
08002700504
trailing characters
08-00-27-00-50-49-
08:00:27:00:50:49:
080027005049-
preceding characters
-08-00-27-00-50-49
:08:00:27:00:50:49
:080027005049]]></teststring>
		</action>
		<action id="MACaddresscapturenumberslookaround" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![\w-:])(?&lt;one>[0-9A-F]{2})(?&lt;delimiter>[-:]?)(?&lt;two>[0-9A-F]{2})\k&lt;delimiter>(?&lt;three>[0-9A-F]{2})\k&lt;delimiter>(?&lt;four>[0-9A-F]{2})\k&lt;delimiter>(?&lt;five>[0-9A-F]{2})\k&lt;delimiter>(?&lt;six>[0-9A-F]{2})(?![\w-:])</regex>
			<description>MAC address (capture numbers; lookaround)&#13;&#10;12-34-56-78-9A-BC or 12:34:56:78:9A:BC or 123456789ABC&#13;&#10;Using lookaround to avoid matching parts of longer strings of alphanumerics with hyphens and colons&#13;&#10;With capturing groups to get all 6 bytes separately</description>
			<teststring><![CDATA[only digits
08-00-27-00-50-49
08:00:27:00:50:49
080027005049
upper case
A8-00-27-00-50-4F
A8:00:27:00:50:4F
A8002700504F
lower case
a8-00-27-00-50-4f
a8:00:27:00:50:4f
a8002700504f

Broken cases:
missing 1 special character
08-00-27-00-5049
08:00:27:00:5049
additional special character
08-00-27-00-50--49
08:00:27:00:50::49
0800270050-49
missing one non special character
08-00-27-00-50-4
08:00:27:00:50:4
08002700504
trailing characters
08-00-27-00-50-49-
08:00:27:00:50:49:
080027005049-
preceding characters
-08-00-27-00-50-49
:08:00:27:00:50:49
:080027005049]]></teststring>
		</action>
		<action id="MACaddresslookaround" caseless="1" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;![\w-:])[0-9A-F]{2}([-:]?)(?:[0-9A-F]{2}\1){4}[0-9A-F]{2}(?![\w-:])</regex>
			<description>MAC address (lookaround)&#13;&#10;12-34-56-78-9A-BC or 12:34:56:78:9A:BC or 123456789ABC&#13;&#10;Using lookaround to avoid matching parts of longer strings of alphanumerics with hyphens and colons</description>
			<teststring><![CDATA[only digits
08-00-27-00-50-49
08:00:27:00:50:49
080027005049
upper case
A8-00-27-00-50-4F
A8:00:27:00:50:4F
A8002700504F
lower case
a8-00-27-00-50-4f
a8:00:27:00:50:4f
a8002700504f

Broken cases:
missing 1 special character
08-00-27-00-5049
08:00:27:00:5049
additional special character
08-00-27-00-50--49
08:00:27:00:50::49
0800270050-49
missing one non special character
08-00-27-00-50-4
08:00:27:00:50:4
08002700504
trailing characters
08-00-27-00-50-49-
08:00:27:00:50:49:
080027005049-
preceding characters
-08-00-27-00-50-49
:08:00:27:00:50:49
:080027005049]]></teststring>
		</action>
		<action id="NationalIDAustriansocialsecuritynumberSozialversicherungsnummer">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[0-9]{4}(?:0[1-9]|[12][0-9]|3[01])(?:0[1-9]|1[012])[0-9]{2}\b</regex>
			<description>National ID: Austrian social security number (Sozialversicherungsnummer)</description>
			<teststring><![CDATA[1788011298]]></teststring>
		</action>
		<action id="NationalIDBulgarianUniformCivilNumber">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[0-9]{2}(?:[024][1-9]|[135][0-2])(?:0[1-9]|[12][0-9]|3[01])[-+]?[0-9]{4}\b</regex>
			<description>National ID: Bulgarian Uniform Civil Number (  )</description>
			<teststring><![CDATA[7523169263]]></teststring>
		</action>
		<action id="NationalIDCanadianSocialInsuranceNumber">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[1-9][0-9]{2}[- ]?[0-9]{3}[- ]?[0-9]{3}\b</regex>
			<description>National ID: Canadian Social Insurance Number</description>
		</action>
		<action id="NationalIDChineseNationalIdentificationCardNumber">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[0-9]{6}(?:19|20)[0-9]{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[12][0-9]|3[01])[0-9]{4}\b</regex>
			<description>National ID: Chinese National Identification Card Number ()</description>
		</action>
		<action id="NationalIDCroatianMasterCitizenNumberMatinibrojgraana">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:0[1-9]|[12][0-9]|3[01])(?:0[1-9]|1[0-2])(?:9[0-9]{2}|0[01][0-9])[0-9]{6}\b</regex>
			<description>National ID: Croatian Master Citizen Number (Matini broj graana)</description>
		</action>
		<action id="NationalIDDanishCivilRegistrationNumberPersonnummerCPRNummer">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:0[1-9]|[12][0-9]|3[01])(?:0[1-9]|1[0-2])[0-9]{2}[-+]?[0-9]{4}\b</regex>
			<description>National ID: Danish Civil Registration Number (Personnummer, CPR Nummer)</description>
		</action>
		<action id="NationalIDFinnishSocialSecurityNumberHenkiltunnus" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:0[1-9]|[12][0-9]|3[01])(?:0[1-9]|1[0-2])[0-9]{2}[-+a][0-9]{3}[a-z0-9]\b</regex>
			<description>National ID: Finnish Social Security Number (Henkiltunnus)</description>
			<teststring><![CDATA[311280-999J]]></teststring>
		</action>
		<action id="NationalIDIndianPermanentAccountNumber" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[a-z]{3}[abcfghjlpt][a-z][0-9]{4}[a-z]\b</regex>
			<description>National ID: Indian Permanent Account Number</description>
		</action>
		<action id="NationalIDIndianVehicleLicensePlateNumber" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:dl ?[1-9]?[0-9] ?[cprstvy]|[a-z]{2} ?[0-9]{1,2}) ?[a-z]{0,2} ?[0-9]{1,4}\b</regex>
			<description>National ID: Indian Vehicle License Plate Number</description>
			<teststring><![CDATA[DL 11 C AA 1111]]></teststring>
		</action>
		<action id="NationalIDItalianFiscalCodeCodicefiscale" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:[bcdfghj-np-tv-z][a-z]{2}){2}[0-9]{2}[a-ehlmprst](?:[04][1-9]|[1256][0-9]|[37][01])(?:[0-9][a-z]{3}|z[0-9]{3})[a-z]\b</regex>
			<description>National ID: Italian Fiscal Code (Codice fiscale)</description>
			<teststring><![CDATA[HDDFTH63H28Z352V]]></teststring>
		</action>
		<action id="NationalIDNorwegianSocialSecurityNumberPersonnummerFdselsnummer">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:0[1-9]|[12][0-9]|3[01])(?:[04][1-9]|[15][0-2])[0-9]{7}\b</regex>
			<description>National ID: Norwegian Social Security Number (Personnummer, Fdselsnummer, SSNR)</description>
		</action>
		<action id="NationalIDRomanianPersonalNumericCodeCodNumericPersonal">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[1-8][0-9]{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[12][0-9]|3[01])(?:0[1-9]|[1-4][0-9]|5[0-2]|99)[0-9]{4}\b</regex>
			<description>National ID: Romanian Personal Numeric Code (Cod Numeric Personal)</description>
			<teststring><![CDATA[1800101221144]]></teststring>
		</action>
		<action id="NationalIDSouthKoreanResidentRegistrationNumber">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[0-9]{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[12][0-9]|3[01])-[0-49][0-9]{6}\b</regex>
			<description>National ID: South Korean Resident Registration Number ()</description>
		</action>
		<action id="NationalIDSwedishPersonalIdentificationNumberPersonnummer">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:19|20)?[0-9]{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[12][0-9]|3[01])[-+]?[0-9]{4}\b</regex>
			<description>National ID: Swedish Personal Identification Number (Personnummer)</description>
		</action>
		<action id="NationalIDTaiwaneseNationalIdentificationCardNumber" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[a-z][12][0-9]{8}\b</regex>
			<description>National ID: Taiwanese National Identification Card Number</description>
		</action>
		<action id="NationalIDUnitedKingdomNationalInsuranceNumber" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[abceghj-prstw-z][abceghj-nprstw-z] ?[0-9]{2} ?[0-9]{2} ?[0-9]{2} ?[a-dfm]?\b</regex>
			<description>National ID: United Kingdom National Insurance Number</description>
			<teststring><![CDATA[AA 01 23 44 B]]></teststring>
		</action>
		<action id="NationalIDUSsocialsecuritynumberexact">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?!000)(?!666)[0-8][0-9]{2}[- ](?!00)[0-9]{2}[- ](?!0000)[0-9]{4}\b</regex>
			<description>National ID: US social security number (exact)</description>
			<teststring><![CDATA[Valid:
123-12-1234
078-05-1120
777-77-7777
888-88-8888

Invalid:
123121234
1234-12-1234
000-12-3456
123-00-4567
123-45-0000
666-12-3456
999-12-3456
]]></teststring>
		</action>
		<action id="NationalIDUSsocialsecuritynumberquick">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[0-9]{3}-[0-9]{2}-[0-9]{4}\b</regex>
			<description>National ID: US social security number (quick)</description>
			<teststring><![CDATA[Valid:
123-12-1234
078-05-1120
777-77-7777
888-88-8888

Invalid:
123121234
1234-12-1234
000-12-3456
123-00-4567
123-45-0000
666-12-3456
999-12-3456
]]></teststring>
		</action>
		<action id="NumberCurrencyamountcentsmandatory" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[+-]?[0-9]{1,3}(?:,?[0-9]{3})*\.[0-9]{2}$</regex>
			<replace>,</replace>
			<description>Number: Currency amount (cents mandatory)&#13;&#10;Optional thousands separators; mandatory two-digit fraction</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="NumberCurrencyamountcentsoptional" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[+-]?[0-9]{1,3}(?:,?[0-9]{3})*(?:\.[0-9]{2})?$</regex>
			<replace>,</replace>
			<description>Number: Currency amount (cents optional)&#13;&#10;Optional thousands separators; optional two-digit fraction</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="NumberCurrencyamountUSEUcentsoptional" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[+-]?[0-9]{1,3}(?:[0-9]*(?:[.,][0-9]{2})?|(?:,[0-9]{3})*(?:\.[0-9]{2})?|(?:\.[0-9]{3})*(?:,[0-9]{2})?)$</regex>
			<replace>,</replace>
			<description>Number: Currency amount US &amp; EU (cents optional)&#13;&#10;Can use US-style 123,456.78 notation and European-style 123.456,78 notation.  Optional thousands separators; optional two-digit fraction</description>
			<teststring><![CDATA[12.34
12.
.34
12,345
12.345
1,234.45
1.234,45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberfloatingpoint" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[-+]?\b[0-9]+(\.[0-9]+)?\b</regex>
			<description>Number: floating point&#13;&#10;Matches an integer or a floating point number with mandatory integer part.  The sign is optional.</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberfloatingpoint" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[-+]?\b[0-9]*\.?[0-9]+\b</regex>
			<description>Number: floating point&#13;&#10;Matches an integer or a floating point number with optional integer part.  The sign is optional.</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberfloatingpointanchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[-+]?[0-9]+(\.[0-9]+)?$</regex>
			<description>Number: floating point (anchored)&#13;&#10;Matches an integer or a floating point number with mandatory integer part.  The sign is optional.</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberfloatingpointanchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[-+]?[0-9]*\.?[0-9]+\b$</regex>
			<description>Number: floating point (anchored)&#13;&#10;Matches an integer or a floating point number with optional integer part.  The sign is optional.</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="NumberhexadecimalCstyle" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b0[xX][0-9a-fA-F]+\b</regex>
			<description>Number: hexadecimal (C-style)</description>
			<teststring><![CDATA[0xDEADBEEF
0xdeadbeef
0XDEADBEEF
0Xdeadbeef
0x12345678

12345678
deadbeef]]></teststring>
		</action>
		<action id="NumberInsertthousandsseparators" purpose="replace" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;=[0-9])(?=(?:[0-9]{3})+(?![0-9]))</regex>
			<replace>,</replace>
			<description>Number: Insert thousands separators&#13;&#10;Replaces 123456789.00 with 123,456,789.00</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberinteger" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b\d+\b</regex>
			<description>Number: integer&#13;&#10;Will match 123 and 456 as separate integer numbers in 123.456</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberinteger" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>(?&lt;!\S)\d++(?!\S)</regex>
			<description>Number: integer&#13;&#10;Does not match numbers like 123.456</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberintegeranchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^\d+$</regex>
			<description>Number: integer (anchored)&#13;&#10;The whole string must consist of only digits</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberintegerwithoptionalsign" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[-+]?\b\d+\b</regex>
			<description>Number: integer with optional sign</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberintegerwithoptionalsignanchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[-+]?\d+$</regex>
			<description>Number: integer with optional sign (anchored)</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberscientificfloatingpoint" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[-+]?(?:\b[0-9]+(?:\.[0-9]*)?|\.[0-9]+\b)(?:[eE][-+]?[0-9]+\b)?</regex>
			<description>Number: scientific floating point&#13;&#10;Matches an integer or a floating point number.&#13;&#10;Integer and fractional parts are both optional.&#13;&#10;Both the sign and exponent are optional.</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
+1234.567e-89
-1234.567e89
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberscientificfloatingpoint" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[-+]?\b[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?\b</regex>
			<description>Number: scientific floating point&#13;&#10;Matches an integer or a floating point number with optional integer part.&#13;&#10;Both the sign and exponent are optional.&#13;&#10;</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
+1234.567e-89
-1234.567e89
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberscientificfloatingpointanchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[-+]?(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)(?:[eE][-+]?[0-9]+)?$</regex>
			<description>Number: scientific floating point (anchored)&#13;&#10;Matches an integer or a floating point number.&#13;&#10;Integer and fractional parts are both optional.&#13;&#10;Both the sign and exponent are optional.</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
+1234.567e-89
-1234.567e89
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numberscientificfloatingpointanchored" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[-+]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?$</regex>
			<description>Number: scientific floating point (anchored)&#13;&#10;Matches an integer or a floating point number with optional integer part.&#13;&#10;Both the sign and exponent are optional.&#13;&#10;</description>
			<teststring><![CDATA[12.34
12.
.34
12.345
1,234.45
1234.45
1234567890
+12.34
-12.34
+1234
-1234
+1234.567e-89
-1234.567e89
Attention: 1 2 3 test
The number 12345678901234567890 is quite long
1+1=2]]></teststring>
		</action>
		<action id="Numericrange0or0059" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[0-5]?[0-9]$</regex>
			<description>Numeric range: 0 or 00..59</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange0or000127" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(0?[0-9]?[0-9]|1[0-1][0-9]|12[0-7])$</regex>
			<description>Numeric range: 0 or 000..127</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange0or000255" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$</regex>
			<description>Numeric range: 0 or 000..255</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange0or000366" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(0?[0-9]?[0-9]|[1-2][0-9][0-9]|3[0-6][0-9]|36[0-6])$</regex>
			<description>Numeric range: 0 or 000..366</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange0or000999" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[0-9]{1,3}$</regex>
			<description>Numeric range: 0 or 000..999</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange0255" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$</regex>
			<description>Numeric range: 0..255</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange0999" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^([0-9]|[1-9][0-9]|[1-9][0-9][0-9])$</regex>
			<description>Numeric range: 0..999</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange000255" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^([01][0-9][0-9]|2[0-4][0-9]|25[0-5])$</regex>
			<description>Numeric range: 000..255</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange000999" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[0-9]{3}$</regex>
			<description>Numeric range: 000..999</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange001999" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(00[1-9]|0[1-9][0-9]|[1-9][0-9][0-9])$</regex>
			<description>Numeric range: 001..999</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange1or001999" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(0{0,2}[1-9]|0?[1-9][0-9]|[1-9][0-9][0-9])$</regex>
			<description>Numeric range: 1 or 001..999</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Numericrange1999" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^([1-9]|[1-9][0-9]|[1-9][0-9][0-9])$</regex>
			<description>Numeric range: 1..999</description>
			<teststring><![CDATA[0
00
000
0000
1
01
001
0001
2
02
002
0002
9
09
009
0009
10
010
0010
59
60
99
099
0099
100
0100
127
128
255
256
365
366
367
999
1000
01000
10000
010000
100000
]]></teststring>
		</action>
		<action id="Passwordcomplexity" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\A(?=\S*?[A-Z])(?=\S*?[a-z])(?=\S*?[0-9])\S{6,}\z</regex>
			<description>Password complexity&#13;&#10;Tests if the input consists of 6 or more characters.&#13;&#10;The input must contain at least one upper case letter, one lower case letter and one digit.</description>
			<teststring><![CDATA[aA1
aaaAAA111
aaaaaa
AAAAAA
111111
aaa111
aaaa1A
a_-a1A
a1A+'"?*=
+'"?*=a1A]]></teststring>
		</action>
		<action id="Passwordcomplexityalphanumeric" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A(?=[-_a-zA-Z0-9]*?[A-Z])(?=[-_a-zA-Z0-9]*?[a-z])(?=[-_a-zA-Z0-9]*?[0-9])[-_a-zA-Z0-9]{6,}\z</regex>
			<description>Password complexity (alphanumeric)&#13;&#10;Tests if the input consists of 6 or more letters, digits, underscores and hyphens.&#13;&#10;The input must contain at least one upper case letter, one lower case letter and one digit.</description>
			<teststring><![CDATA[aA1
aaaAAA111
aaaaaa
AAAAAA
111111
aaa111
aaaa1A
a_-a1A
a1A+'"?*=
+'"?*=a1A]]></teststring>
		</action>
		<action id="PasswordcomplexityASCII" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A(?=[\x20-\x7E]*?[A-Z])(?=[\x20-\x7E]*?[a-z])(?=[\x20-\x7E]*?[0-9])[\x20-\x7E]{6,}\z</regex>
			<description>Password complexity (ASCII)&#13;&#10;Tests if the input consists of 6 or more ASCII characters.&#13;&#10;The input must contain at least one upper case letter, one lower case letter and one digit.</description>
			<teststring><![CDATA[aA1
aaaAAA111
aaaaaa
AAAAAA
111111
aaa111
aaaa1A
a_-a1A
a1A+'"?*=
+'"?*=a1A]]></teststring>
		</action>
		<action id="PasswordcomplexityVBScriptJScript">
			<flavor>
				<builtin>msie</builtin>
			</flavor>
			<regex>^(?=\S*?[A-Z])(?=\S*?[a-z])(?=\S*?[0-9])\S+$</regex>
			<replace>${First}</replace>
			<description>Password complexity (VBScript/JScript)&#13;&#10;The regular expression engine in Internet Explorer, which is used by JScript (Microsoft's JavaScript) and VBScript, has a bug that causes the password complexity regular expressions in this library to fail if some of the required characters are not within the first 6 characters of the password.  The bug is that Microsoft's regex engine incorrectly applies the lookaheads to only the first 6 characters of the string, because the lookaheads in the regex are followed by \S{6,}.  The workaround is to use \S+ in the regex, which allows passwords of any length.  Use an extra line of VBScript or JScript code to check the length of the password.&#13;&#10;</description>
		</action>
		<action id="PathExtractdriveletter" caseless="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>^([a-z]):</regex>
			<replace>$$</replace>
			<description>Path: Extract drive letter&#13;&#10;Extract the drive letter from a string known to hold a valid Windows path</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\
\\server\c$
\\server\c$\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
Subfolder\MyFile.txt
\SubFolder\MyFile.txt
..\SubFolder\MyFile.txt
..\SubFolder\
..\SubFolder
SubFolder

Incomplete:
c:
\\server]]></teststring>
		</action>
		<action id="PathExtractextension" caseless="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\.[^.\\/:*?"&lt;>|\x00-\x1F]+$</regex>
			<replace>$$</replace>
			<description>Path: Extract extension</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$
\\server\c$\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
Subfolder\MyFile.txt
\SubFolder\MyFile.txt
..\SubFolder\MyFile.txt
..\SubFolder\
..\SubFolder
SubFolder

Incomplete:
c:
\\server
\\server\
]]></teststring>
		</action>
		<action id="PathExtractfilename" caseless="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>[^\\/:*?"&lt;>|\x00-\x1F]+$</regex>
			<replace>$$</replace>
			<description>Path: Extract file name</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$
\\server\c$\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
Subfolder\MyFile.txt
\SubFolder\MyFile.txt
..\SubFolder\MyFile.txt
..\SubFolder\
..\SubFolder
SubFolder

Incomplete:
c:
\\server
\\server\
]]></teststring>
		</action>
		<action id="PathExtractfolder" caseless="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>^([a-z]:|\\\\[a-z0-9 %._-]+\\[a-z0-9 $%._-]+)?(\\?(?:[^\\/:*?"&lt;>|\x00-\x1F]+\\)+)</regex>
			<description>Path: Extract folder&#13;&#10;Extract the folder from a string known to hold a valid Windows, UNC, or relative path</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\
\\server\c$
\\server\c$\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
Subfolder\MyFile.txt
\SubFolder\MyFile.txt
..\SubFolder\MyFile.txt
..\SubFolder\
..\SubFolder
SubFolder

Incomplete:
c:
\\server]]></teststring>
		</action>
		<action id="PathExtractUNCserverandshare" caseless="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>^\\\\(?&lt;server>[a-z0-9 %._-]+)\\(?&lt;share>[a-z0-9 $%._-]+)</regex>
			<replace>$$</replace>
			<description>Path: Extract UNC server and share&#13;&#10;Extract the server and share from a string known to hold a valid UNC path</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\
\\server\c$
\\server\c$\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
Subfolder\MyFile.txt
\SubFolder\MyFile.txt
..\SubFolder\MyFile.txt
..\SubFolder\
..\SubFolder
SubFolder

Incomplete:
c:
\\server]]></teststring>
		</action>
		<action id="PathRemoveinvalidfilenamecharacters" purpose="replace" namedduplicate="1">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>[\\/:"*?&lt;>|\x00-\x1F]+</regex>
			<description>Path: Remove invalid file name characters</description>
			<teststring><![CDATA[Are \you/ a *?.txt]]></teststring>
		</action>
		<action id="PathRemoveinvalidpathnamecharacters" purpose="replace" namedduplicate="1">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>[/:"*?&lt;>|\x00-\x1F]+</regex>
			<description>Path: Remove invalid path name characters</description>
			<teststring><![CDATA[Are \you/ a *?.txt]]></teststring>
		</action>
		<action id="PathReplacespaceswithunderscores" purpose="replace" namedduplicate="1">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex> </regex>
			<replace>_</replace>
			<description>Path: Replace spaces with underscores</description>
			<teststring><![CDATA[Are \you/ a *?.txt]]></teststring>
		</action>
		<action id="PathWindows" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\b[a-z]:\\                                                   # Drive&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*  # Folder&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?    # File</regex>
			<description>Path: Windows&#13;&#10;Not anchored so you can use it to find paths inside files or longer strings.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsanchored" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\A&#13;&#10;[a-z]:\\                                                     # Drive&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*  # Folder&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?    # File&#13;&#10;\z</regex>
			<description>Path: Windows (anchored)&#13;&#10;Anchored so you can use it to validate strings as paths.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowscapture" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>(?&lt;drive> \b[a-z]:\\)&#13;&#10;(?&lt;folder>(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;(?&lt;file>  (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)</regex>
			<description>Path: Windows (capture)&#13;&#10;Different elements of the path are captured into backreferences.&#13;&#10;Not anchored so you can use it to find paths inside files or longer strings.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowscaptureanchored" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\A&#13;&#10;(?&lt;drive> \b[a-z]:\\)&#13;&#10;(?&lt;folder>(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;(?&lt;file>  (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;\z</regex>
			<description>Path: Windows (capture; anchored)&#13;&#10;Different elements of the path are captured into backreferences.&#13;&#10;Anchored so you can use it to validate strings as paths.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsorUNC" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>(?>\b[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\  # Drive&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*     # Folder&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?       # File</regex>
			<description>Path: Windows or UNC&#13;&#10;Not anchored so you can use it to find paths inside files or longer strings.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsorUNCanchored" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\A&#13;&#10;(?>[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\  # Drive&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*   # Folder&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?     # File&#13;&#10;\z</regex>
			<description>Path: Windows or UNC (anchored)&#13;&#10;Anchored so you can use it to validate strings as paths.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsorUNCcapture" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>(?&lt;drive> (?>\b[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\)&#13;&#10;(?&lt;folder>(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;(?&lt;file>  (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)</regex>
			<description>Path: Windows or UNC (capture)&#13;&#10;Different elements of the path are captured into backreferences.&#13;&#10;Not anchored so you can use it to find paths inside files or longer strings.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsorUNCcaptureanchored" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\A&#13;&#10;(?&lt;drive> (?>[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\)&#13;&#10;(?&lt;folder>(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;(?&lt;file>  (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;\z</regex>
			<description>Path: Windows or UNC (capture; anchored)&#13;&#10;Different elements of the path are captured into backreferences.&#13;&#10;Anchored so you can use it to validate strings as paths.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsUNCorrelative" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>(?>(?>\b[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\          # Drive&#13;&#10; | (?>\.{0,2}\\)?[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\?)  # Relative path&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*                # Folder&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?                  # File</regex>
			<description>Path: Windows, UNC, or relative&#13;&#10;Not anchored so you can use it to find paths inside files or longer strings.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsUNCorrelativeanchored" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\A&#13;&#10;(?>(?>[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\            # Drive&#13;&#10; | (?>\.{0,2}\\)?[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\?)  # Relative path&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*                # Folder&#13;&#10;(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?                  # File&#13;&#10;\z</regex>
			<description>Path: Windows, UNC, or relative (anchored)&#13;&#10;Anchored so you can use it to validate strings as paths.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsUNCorrelativecapturenotempty" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>(?:&#13;&#10;   (?&lt;drive>         (?>\b[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\)&#13;&#10;   (?&lt;folder>        (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;   (?&lt;file>          (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;|  (?&lt;relative>      (?>\.{0,2}\\))&#13;&#10;   (?&lt;folder>        (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;   (?&lt;file>          (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;|  (?&lt;relativefolder>(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)+)&#13;&#10;   (?&lt;file>          (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;|  (?&lt;relativefile>  (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]))&#13;&#10;)&#13;&#10;</regex>
			<description>Path: Windows, UNC, or relative (capture, not empty)&#13;&#10;This regex uses separate alternatives for relative paths to avoid matching empty strings.&#13;&#10;You can change the names of the capturing groups if your application does not allow multiple groups to have the same name.&#13;&#10;Not anchored so you can use it to find paths inside files or longer strings.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsUNCorrelativecapturenotemptyanchored" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\A(?:&#13;&#10;   (?&lt;drive>         (?>[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80})\\)&#13;&#10;   (?&lt;folder>        (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;   (?&lt;file>          (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;|  (?&lt;relative>      (?>\.{0,2}\\))&#13;&#10;   (?&lt;folder>        (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;   (?&lt;file>          (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;|  (?&lt;relativefolder>(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)+)&#13;&#10;   (?&lt;file>          (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;|  (?&lt;relativefile>  (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]))&#13;&#10;)\z&#13;&#10;</regex>
			<description>Path: Windows, UNC, or relative (capture, not empty; anchored)&#13;&#10;This regex uses separate alternatives for relative paths to avoid matching empty strings.&#13;&#10;You can change the names of the capturing groups if your application does not allow multiple groups to have the same name.&#13;&#10;Anchored so you can use it to validate strings as paths.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PathWindowsUNCorrelativecaptureemptyanchored" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>vbnet20</builtin>
			</flavor>
			<regex>\A&#13;&#10;(?&lt;drive> (?>[a-z]:|\\\\[a-z0-9 %._~-]{1,63}\\[a-z0-9 $%._~-]{1,80}|\.{0,2})\\)?&#13;&#10;(?&lt;folder>(?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F]\\)*)&#13;&#10;(?&lt;file>  (?>[^\\/:*?"&lt;>|\x00-\x1F]{0,254}[^.\\/:*?"&lt;>|\x00-\x1F])?)&#13;&#10;\z</regex>
			<description>Path: Windows, UNC, or relative (capture; empty; anchored)&#13;&#10;Warning: This regular expression will match the empty string, because the drive, folder, and file groups in this regex are all optional.  Use the "not empty" version of this regex if you don't have a way to filter out empty strings first.&#13;&#10;Anchored so you can use it to validate strings as paths.&#13;&#10;Atomic groups are an optimization.  You can replace them with non-capturing group if your application doesn't support atomic groups.</description>
			<teststring><![CDATA[Local:
c:\
c:\autoexec.bat
c:\Data\Subfolder
c:\Data\Subfolder\
c:\Data\Subfolder\MyFile.txt
c:\My Documents\My Letters
c:\My Documents\My Letters\
c:\My Documents\My Letters\Letter to Mum.txt

UNC:
\\server\c$\
\\192.168.0.2\share\
\\server\c$\autoexec.bat
\\server\data\Subfolder
\\server\data\Subfolder\
\\server\data\Subfolder\MyFile.txt
\\server\docs\My Letters
\\server\docs\My Letters\
\\server\docs\My Letters\Letter to Mum.txt

Relative:
MyFile.txt
SubFolder
SubFolder\
Subfolder\MyFile.txt
\MyFile.txt
\Folder
\Folder\
\Folder\MyFile.txt
..\MyFile.txt
..\SubFolder
..\SubFolder\
..\SubFolder\MyFile.txt
.\MyFile.txt
.\SubFolder
.\SubFolder\
.\SubFolder\MyFile.txt

Incomplete:
c:
\\server
\\server\

Invalid:
c:\*.txt
c:\<Folder>\MyFile.txt
c:\Invalid\.
c:\Invalid\..
c:\Invalid\Dot.
c:\Invalid\Dot.txt.
c:\Dot.\MyFile.txt
c:\Invalid\.\MyFile.txt
c:\Invalid\..\MyFile.txt
\\Invalid\c?\Subfolder]]></teststring>
		</action>
		<action id="PhoneNumberNorthAmerica">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\(?\b[2-9][0-9]{2}\)?[-. ]?[2-9][0-9]{2}[-. ]?[0-9]{4}\b</regex>
			<replace>($1) $2-$3</replace>
			<description>Phone Number (North America)&#13;&#10;Matches 3334445555, 333.444.5555, 333-444-5555, 333 444 5555, (333) 444 5555 and all combinations thereof.</description>
			<teststring><![CDATA[Phone Number (North America)
Matches 3334445555, 333.444.5555, 333-444-5555, 333 444 5555, (333) 444 5555 and all combinations thereof, like 333 4445555, (333)4445555 or 333444-5555.
Does not match international notation +13334445555, but matches domestic part in +1 333 4445555.]]></teststring>
		</action>
		<action id="PhoneNumberConversionNorthAmerica" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\(?\b([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})\b</regex>
			<replace>($1) $2-$3</replace>
			<description>Phone Number Conversion (North America)&#13;&#10;Matches 3334445555, 333.444.5555, 333-444-5555, 333 444 5555, (333) 444 5555 and all combinations thereof.&#13;&#10;Replaces all those with (333) 444-5555</description>
			<teststring><![CDATA[Phone Number (North America)
Matches 3334445555, 333.444.5555, 333-444-5555, 333 444 5555, (333) 444 5555 and all combinations thereof, like 333 4445555, (333)4445555 or 333444-5555.
Replaces all those with (333) 444-5555.
Does not match international notation +13334445555, but matches domestic part in +1 333 4445555.]]></teststring>
		</action>
		<action id="PostalcodeCanada" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[ABCEGHJKLMNPRSTVXY][0-9][A-Z] [0-9][A-Z][0-9]\b</regex>
			<description>Postal code (Canada)</description>
			<teststring><![CDATA[Valid postal codes:
A3A 3A3
Y9Z 8X7

Invalid postal codes:
A3A3A3
Y9Z8X7
ABC DEF
123 456
]]></teststring>
		</action>
		<action id="PostalcodeUK" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[A-Z]{1,2}[0-9][A-Z0-9]? [0-9][ABD-HJLNP-UW-Z]{2}\b</regex>
			<description>Postal code (UK)</description>
			<teststring><![CDATA[Valid postal codes:
A3 3AB
BC4 4BD
EF56 5FE
GH6J 6JG
K7L 7LN

Invalid postal codes:
A33AB
BC44BD
EF565FE
GH6J6JG
K7L7LN
12 345
AB DEF]]></teststring>
		</action>
		<action id="Programmingcomment" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>#.*$</regex>
			<description>Programming: # comment&#13;&#10;&#13;&#10;Single-line comment started by # anywhere on the line</description>
			<teststring><![CDATA[# comment
another # comment
no comment]]></teststring>
		</action>
		<action id="Programmingpreprocessorstatement" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^\s*#.*$</regex>
			<description>Programming: # preprocessor statement&#13;&#10;&#13;&#10;Started by # at the start of the line, possibly preceded by some whitespace.</description>
			<teststring><![CDATA[# pragma
no # pragma
no pragma]]></teststring>
		</action>
		<action id="Programmingunlimitednestedcomment" dotall="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>/\*(?>[^*/]+|\*[^/]|/[^*])*(?>(?R)(?>[^*/]+|\*[^/]|/[^*])*)*\*/</regex>
			<description>Programming: /* /* /* unlimited */ nested */ comment */&#13;&#10;&#13;&#10;Matches a comment delimited by /* and */ allowing unlimited levels of nested comments inside the comment.&#13;&#10;The atomic groups are necessary to prevent catastrophic backtracking if the subject string contains unbalanced /* characters.</description>
			<teststring><![CDATA[/* comment */
no comment
/* comment
   spanning
   multiple
   lines */
/* comment /* nesting */ of /* two */ levels supported */
/* comment /* nesting */ of /* /* more than */ two levels */ also supported */
/* 1 /* 2 /* 3 /* 4 /* 5 */ */ */ */ */
/* /* /* /* /* 5 */ 4 */ 3 */ 2 */ 1 */]]></teststring>
		</action>
		<action id="Programmingonenestedcomment" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>/\*(?>[^*/]+|\*[^/]|/[^*]|/\*(?>[^*/]+|\*[^/]|/[^*])*\*/)*\*/</regex>
			<description>Programming: /* /* one nested */ comment */&#13;&#10;&#13;&#10;Matches a comment delimited by /* and */ allowing one level of nested comments inside the comment.&#13;&#10;The atomic groups are necessary to prevent catastrophic backtracking if the subject string contains unbalanced /* characters.</description>
			<teststring><![CDATA[/* comment */
no comment
/* comment
   spanning
   multiple
   lines */
/* comment /* nesting */ of /* two */ levels supported */
/* comment /* nesting */ of /* /* more than */ two levels */ not supported */]]></teststring>
		</action>
		<action id="Programmingcomment" dotall="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>/\*.*?\*/</regex>
			<description>Programming: /* comment */&#13;&#10;&#13;&#10;Does not match nested comments.  Most languages, including C, Java, C#, etc. do not allow comments to be nested.  I.e. the first */ closes the comment.</description>
			<teststring><![CDATA[/* comment */
no comment
/* comment
   spanning
   multiple
   lines */
/* comment /* nesting */ prohibited */]]></teststring>
		</action>
		<action id="Programmingcomment" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>//.*$</regex>
			<description>Programming: // comment&#13;&#10;&#13;&#10;Single-line comment started by // anywhere on the line</description>
			<teststring><![CDATA[// comment
another // comment
no comment]]></teststring>
		</action>
		<action id="Programmingcomment" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>//.*$</regex>
			<description>Programming: // comment&#13;&#10;&#13;&#10;Single-line comment started by // anywhere on the line</description>
			<teststring><![CDATA[// comment
another // comment
// comment using a \
for continuation on the next line
no comment]]></teststring>
		</action>
		<action id="Programmingcommentwithcontinuation" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>//[^\\\r\n]*+(?:\\\r?+\n?+[^\\\r\n]*+)*+</regex>
			<description>Programming: // comment with \ continuation&#13;&#10;&#13;&#10;Single-line comment started by // anywhere on the line&#13;&#10;\ at the end of the line makes the comment continue on the next line</description>
			<teststring><![CDATA[// comment
another // comment
// comment using a \
for continuation on the next line
no comment]]></teststring>
		</action>
		<action id="ProgrammingGUIDnobraces" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[A-F0-9]{8}(?:-[A-F0-9]{4}){3}-[A-F0-9]{12}\b</regex>
			<description>Programming: GUID (no braces)&#13;&#10;Microsoft-style GUID, numbers only.&#13;&#10;Don't forget to turn on the "case insensitive" option if you copy and paste this regex.</description>
			<teststring><![CDATA[GUID:
12345678-90AB-CDEF-1234-567890ABCDEF

GUIDs with brackets:
{12345678-90AB-CDEF-1234-567890ABCDEF}
(12345678-90AB-CDEF-1234-567890ABCDEF)

GUIDs with mismatched brackets:
(12345678-90AB-CDEF-1234-567890ABCDEF}
{12345678-90AB-CDEF-1234-567890ABCDEF)

Invalid GUIDs:
1234567890ABCDEF1234567890ABCDEF
X2345678-90AB-CDEF-1234-567890ABCDEX
012345678-90AB-CDEF-1234-567890ABCDEF0
2345678-90AB-CDEF-1234-567890ABCDE]]></teststring>
		</action>
		<action id="ProgrammingGUIDoptionalbracketsusingalternation" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b[A-F0-9]{8}(?:-[A-F0-9]{4}){3}-[A-F0-9]{12}\b|\(\b[A-F0-9]{8}(?:-[A-F0-9]{4}){3}-[A-F0-9]{12}\b\)|\{\b[A-F0-9]{8}(?:-[A-F0-9]{4}){3}-[A-F0-9]{12}\b\}</regex>
			<description>Programming: GUID (optional brackets using alternation)&#13;&#10;Microsoft-style GUID, with optional parentheses or braces.&#13;&#10;(Long version using alternation, if your regex flavor doesn't support conditionals.)</description>
			<teststring><![CDATA[GUID:
12345678-90AB-CDEF-1234-567890ABCDEF

GUIDs with brackets:
{12345678-90AB-CDEF-1234-567890ABCDEF}
(12345678-90AB-CDEF-1234-567890ABCDEF)

GUIDs with mismatched brackets:
(12345678-90AB-CDEF-1234-567890ABCDEF}
{12345678-90AB-CDEF-1234-567890ABCDEF)

Invalid GUIDs:
1234567890ABCDEF1234567890ABCDEF
X2345678-90AB-CDEF-1234-567890ABCDEX
012345678-90AB-CDEF-1234-567890ABCDEF0
2345678-90AB-CDEF-1234-567890ABCDE]]></teststring>
		</action>
		<action id="ProgrammingGUIDoptionalbracketsusingconditionals" caseless="1" namedduplicate="1">
			<flavor>
				<builtin>csharp20</builtin>
			</flavor>
			<regex>(?:(\()|(\{))?\b[A-F0-9]{8}(?:-[A-F0-9]{4}){3}-[A-F0-9]{12}\b(?(1)\))(?(2)\})</regex>
			<description>Programming: GUID (optional brackets using conditionals)&#13;&#10;Microsoft-style GUID, with optional parentheses or braces.&#13;&#10;Short version, illustrating the use of regex conditionals.  Not all regex flavors support conditionals.  Also, when applied to large chunks of data, the regex using conditionals will likely be slower than the long version.  Straight alternation is much easier to optimize for a regex engine.</description>
			<teststring><![CDATA[GUID:
12345678-90AB-CDEF-1234-567890ABCDEF

GUIDs with brackets:
{12345678-90AB-CDEF-1234-567890ABCDEF}
(12345678-90AB-CDEF-1234-567890ABCDEF)

GUIDs with mismatched brackets:
(12345678-90AB-CDEF-1234-567890ABCDEF}
{12345678-90AB-CDEF-1234-567890ABCDEF)

Invalid GUIDs:
1234567890ABCDEF1234567890ABCDEF
X2345678-90AB-CDEF-1234-567890ABCDEX
012345678-90AB-CDEF-1234-567890ABCDEF0
2345678-90AB-CDEF-1234-567890ABCDE]]></teststring>
		</action>
		<action id="ProgrammingGUIDwithbraces" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\{[A-F0-9]{8}(?:-[A-F0-9]{4}){3}-[A-F0-9]{12}\}</regex>
			<description>Programming: GUID (with braces)&#13;&#10;Microsoft-style GUID, requiring braces.&#13;&#10;Don't forget to turn on the "case insensitive" option if you copy and paste this regex.</description>
			<teststring><![CDATA[GUID:
12345678-90AB-CDEF-1234-567890ABCDEF

GUIDs with brackets:
{12345678-90AB-CDEF-1234-567890ABCDEF}
(12345678-90AB-CDEF-1234-567890ABCDEF)

GUIDs with mismatched brackets:
(12345678-90AB-CDEF-1234-567890ABCDEF}
{12345678-90AB-CDEF-1234-567890ABCDEF)

Invalid GUIDs:
1234567890ABCDEF1234567890ABCDEF
X2345678-90AB-CDEF-1234-567890ABCDEX
012345678-90AB-CDEF-1234-567890ABCDEF0
2345678-90AB-CDEF-1234-567890ABCDE]]></teststring>
		</action>
		<action id="ProgrammingRemoveescapes" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\\(.)</regex>
			<replace>$1</replace>
			<description>Programming: Remove escapes&#13;&#10;Remove backslashes used to escape other characters</description>
			<teststring><![CDATA[\\ \" \n \\\\ \\\"]]></teststring>
		</action>
		<action id="ProgrammingString">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>"[^"\r\n]*"</regex>
			<description>Programming: String&#13;&#10;Quotes may not appear in the string.  The string cannot span multiple lines.</description>
			<teststring><![CDATA["string"
"two""strings"
"multi
 line
 string"
"string with \"quotes\""
"multi
 line
 string
 with
 \"quotes\""]]></teststring>
		</action>
		<action id="ProgrammingStringescapequotes">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>"[^"\\\r\n]*(?:\\.[^"\\\r\n]*)*"</regex>
			<description>Programming: String (escape quotes)&#13;&#10;Quotes may appear in the string when escaped with a backslash.&#13;&#10;The string cannot span multiple lines.</description>
			<teststring><![CDATA["string"
"two""strings"
"multi
 line
 string"
"string with \"quotes\""
"multi
 line
 string
 with
 \"quotes\""]]></teststring>
		</action>
		<action id="ProgrammingStringmultilineescapequotes">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>"[^"\\]*(?:\\.[^"\\]*)*"</regex>
			<description>Programming: String (multiline; escape quotes)&#13;&#10;Quotes may appear in the string when escaped with a backslash.&#13;&#10;The string may span multiple lines.</description>
			<teststring><![CDATA["string"
"two""strings"
"multi
 line
 string"
"string with \"quotes\""
"multi
 line
 string
 with
 \"quotes\""]]></teststring>
		</action>
		<action id="QuotesReplacesmartdoublequoteswithstraightdoublequotes" purpose="replace">
			<flavor>
				<builtin>phppreg5609</builtin>
			</flavor>
			<regex>[\x84\x93\x94]</regex>
			<replace>"</replace>
			<description>Quotes: Replace smart double quotes with straight double quotes.&#13;&#10;ANSI version for use with 8-bit regex engines and the Windows code page 1252.</description>
			<testdata format="win1252">InN0cmFpZ2h0IgqTc21hcnSU</testdata>
		</action>
		<action id="QuotesReplacesmartdoublequoteswithstraightdoublequotes" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[\u201C\u201D\u201E\u201F\u2033\u2036]</regex>
			<replace>"</replace>
			<description>Quotes: Replace smart double quotes with straight double quotes.&#13;&#10;Unicode version for use with Unicode regex engines.</description>
			<teststring><![CDATA["straight"
smart]]></teststring>
		</action>
		<action id="QuotesReplacesmartsinglequotesandapostropheswithstraightsingleq" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[\u2018\u2019\u201A\u201B\u2032\u2035]</regex>
			<replace>'</replace>
			<description>Quotes: Replace smart single quotes and apostrophes with straight single quotes.&#13;&#10;Unicode version for use with Unicode regex engines.</description>
			<teststring><![CDATA[Straight's
Smarts
'straight'
smart]]></teststring>
		</action>
		<action id="QuotesReplacesmartsinglequotesandapostropheswithstraightsingleq" purpose="replace">
			<flavor>
				<builtin>phppreg5609</builtin>
			</flavor>
			<regex>[\x82\x91\x92]</regex>
			<replace>'</replace>
			<description>Quotes: Replace smart single quotes and apostrophes with straight single quotes.&#13;&#10;ANSI version for use with 8-bit regex engines and the Windows code page 1252.</description>
			<testdata format="win1252">U3RyYWlnaHQncwpTbWFydJJzCidzdHJhaWdodCcKkXNtYXJ0kg==</testdata>
		</action>
		<action id="QuotesReplacestraightapostropheswithsmartapostrophes" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b'\b</regex>
			<replace></replace>
			<description>Quotes: Replace straight apostrophes with smart apostrophes</description>
			<teststring><![CDATA[Straight's
Smarts
'straight'
smart]]></teststring>
		</action>
		<action id="QuotesReplacestraightdoublequoteswithsmartdoublequotes" purpose="replace">
			<flavor>
				<builtin>phppreg5609</builtin>
			</flavor>
			<regex>\B"\b([^"\x84\x93\x94\r\n]+)\b"\B</regex>
			<replace>$1</replace>
			<description>Quotes: Replace straight double quotes with smart double quotes.&#13;&#10;ANSI version for use with 8-bit regex engines and the Windows code page 1252.</description>
			<testdata format="win1252">InN0cmFpZ2h0IgqTc21hcnSU</testdata>
		</action>
		<action id="QuotesReplacestraightdoublequoteswithsmartdoublequotes" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\B"\b([^"\u201C\u201D\u201E\u201F\u2033\u2036\r\n]+)\b"\B</regex>
			<replace>$1</replace>
			<description>Quotes: Replace straight double quotes with smart double quotes.&#13;&#10;Unicode version for use with Unicode regex engines.</description>
			<teststring><![CDATA["straight"
smart]]></teststring>
		</action>
		<action id="QuotesReplacestraightsinglequoteswithsmartsinglequotes" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\B'\b([^'\u2018\u2019\u201A\u201B\u2032\u2035\r\n]+)\b'\B</regex>
			<replace>$1</replace>
			<description>Quotes: Replace straight single quotes with smart single quotes.&#13;&#10;Unicode version for use with Unicode regex engines.</description>
			<teststring><![CDATA[Straight's
Smarts
'straight'
smart]]></teststring>
		</action>
		<action id="QuotesReplacestraightsinglequoteswithsmartsinglequotes" purpose="replace">
			<flavor>
				<builtin>phppreg5609</builtin>
			</flavor>
			<regex>\B'\b([^'\x82\x91\x92\r\n]+)\b'\B</regex>
			<replace>$1</replace>
			<description>Quotes: Replace straight single quotes with smart single quotes.&#13;&#10;ANSI version for use with 8-bit regex engines and the Windows code page 1252.</description>
			<testdata format="win1252">U3RyYWlnaHQncwpTbWFydJJzCidzdHJhaWdodCcKkXNtYXJ0kg==</testdata>
		</action>
		<action id="RegexEscapemetacharacters" purpose="replace" multiline="1" namedduplicate="1">
			<flavor>
				<builtin>epp6</builtin>
			</flavor>
			<regex>[][{}()*+?.\\^$|]</regex>
			<replace>\\$0</replace>
			<description>Regex: Escape metacharacters&#13;&#10;Place a backslash in front of the regular expression metacharacters</description>
			<teststring><![CDATA[These need to be escaped: []{}()*+?.\\^$|]]></teststring>
		</action>
		<action id="SecurityASCIIcodecharactersexcltabandCRLF">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[\x00\x08\x0B\x0C\x0E-\x1F]</regex>
			<description>Security: ASCII code characters excl. tab and CRLF&#13;&#10;Matches any single non-printable code character that may cause trouble in certain situations.&#13;&#10;Excludes tabs and line breaks.</description>
		</action>
		<action id="SecurityASCIIcodecharactersincltabandCRLF">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[\x00-\x1F]</regex>
			<description>Security: ASCII code characters incl. tab and CRLF&#13;&#10;Matches any single non-printable code character that may cause trouble in certain situations.&#13;&#10;Includes tabs and line breaks.</description>
		</action>
		<action id="SecurityEscapequotesandbackslashes" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[\\'"]</regex>
			<replace>\\$0</replace>
			<description>Security: Escape quotes and backslashes&#13;&#10;E.g. escape user input before inserting it into a SQL statement</description>
			<teststring><![CDATA[\ and " need to be escaped]]></teststring>
		</action>
		<action id="SecurityUnicodecodeandunassignedcharactersexcltabandCRLF">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[^\P{C}\t\r\n]</regex>
			<description>Security: Unicode code and unassigned characters excl. tab and CRLF&#13;&#10;Matches any single non-printable code character that may cause trouble in certain situations.&#13;&#10;Also matches any Unicode code point that is unused in the current Unicode standard, and thus should not occur in text as it cannot be displayed.&#13;&#10;Excludes tabs and line breaks.</description>
		</action>
		<action id="SecurityUnicodecodeandunassignedcharactersincltabandCRLF">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\p{C}</regex>
			<description>Security: Unicode code and unassigned characters incl. tab and CRLF&#13;&#10;Matches any single non-printable code character that may cause trouble in certain situations.&#13;&#10;Also matches any Unicode code point that is unused in the current Unicode standard, and thus should not occur in text as it cannot be displayed.&#13;&#10;Includes tabs and line breaks.</description>
		</action>
		<action id="SecurityUnicodecodecharactersexcltabandCRLF">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[^\P{Cc}\t\r\n]</regex>
			<description>Security: Unicode code characters excl. tab and CRLF&#13;&#10;Matches any single non-printable code character that may cause trouble in certain situations.&#13;&#10;Excludes tabs and line breaks.</description>
		</action>
		<action id="SecurityUnicodecodecharactersincltabandCRLF">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\p{Cc}</regex>
			<description>Security: Unicode code characters incl. tab and CRLF&#13;&#10;Matches any single non-printable code character that may cause trouble in certain situations.&#13;&#10;Includes tabs and line breaks.</description>
		</action>
		<action id="Trimwhitespaceincludinglinebreaksattheendofthestring" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\s+\z</regex>
			<description>Trim whitespace (including line breaks) at the end of the string</description>
			<teststring><![CDATA[ 1 space
  2 spaces
   3 spaces   ]]></teststring>
		</action>
		<action id="Trimwhitespaceincludinglinebreaksatthestartandtheendofthestring" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A\s+|\s+\z</regex>
			<description>Trim whitespace (including line breaks) at the start and the end of the string</description>
			<teststring><![CDATA[ 1 space
  2 spaces
   3 spaces   ]]></teststring>
		</action>
		<action id="Trimwhitespaceincludinglinebreaksatthestartofthestring" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\A\s+</regex>
			<description>Trim whitespace (including line breaks) at the start of the string</description>
			<teststring><![CDATA[ 1 space
  2 spaces
   3 spaces   ]]></teststring>
		</action>
		<action id="Trimwhitespaceattheendofeachline" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>[ \t]+$</regex>
			<description>Trim whitespace at the end of each line</description>
			<teststring><![CDATA[ 1 space
  2 spaces
   3 spaces   ]]></teststring>
		</action>
		<action id="Trimwhitespaceatthestartandtheendofeachline" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ \t]+|[ \t]+$</regex>
			<description>Trim whitespace at the start and the end of each line</description>
			<teststring><![CDATA[ 1 space
  2 spaces
   3 spaces   ]]></teststring>
		</action>
		<action id="Trimwhitespaceatthestartofeachline" purpose="replace" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^[ \t]+</regex>
			<description>Trim whitespace at the start of each line</description>
			<teststring><![CDATA[ 1 space
  2 spaces
   3 spaces   ]]></teststring>
		</action>
		<action id="URLDifferentURLparts" caseless="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b((?#protocol)https?|ftp)://((?#domain)[-A-Z0-9.]+)((?#file)/[-A-Z0-9+&amp;@#/%=~_|!:,.;]*)?((?#parameters)\?[A-Z0-9+&amp;@#/%=~_|!:,.;]*)?</regex>
			<description>URL: Different URL parts&#13;&#10;Protocol, domain name, page and CGI parameters are captured into backreferenes 1 through 4</description>
			<teststring><![CDATA[http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.]]></teststring>
		</action>
		<action id="URLDifferentURLpartsnamedcapture" caseless="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b(?&lt;protocol>https?|ftp)://(?&lt;domain>[-A-Z0-9.]+)(?&lt;file>/[-A-Z0-9+&amp;@#/%=~_|!:,.;]*)?(?&lt;parameters>\?[A-Z0-9+&amp;@#/%=~_|!:,.;]*)?</regex>
			<description>URL: Different URL parts (named capture)&#13;&#10;Protocol, domain name, page and CGI parameters are captured into named capturing groups.&#13;&#10;Works as it is with .NET, and after conversion by RegexBuddy on the Use page with Python, PHP/preg and PCRE.</description>
			<teststring><![CDATA[http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.]]></teststring>
		</action>
		<action id="URLFindinfulltext" caseless="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b(https?|ftp|file)://[-A-Z0-9+&amp;@#/%?=~_|$!:,.;]*[A-Z0-9+&amp;@#/%=~_|$]</regex>
			<description>URL: Find in full text&#13;&#10;The final character class makes sure that if an URL is part of some text, punctuation such as a comma or full stop after the URL is not interpreted as part of the URL.</description>
			<teststring><![CDATA[regexbuddy.com
www.regexbuddy.com
http://regexbuddy.com
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.
"www.domain.com/quoted URL with spaces"
support@regexbuddy.com]]></teststring>
		</action>
		<action id="URLFindinfulltextprotocoloptional" caseless="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b(?:(?:https?|ftp|file)://|www\.|ftp\.)[-A-Z0-9+&amp;@#/%=~_|$?!:,.]*[A-Z0-9+&amp;@#/%=~_|$]</regex>
			<description>URL: Find in full text (protocol optional)&#13;&#10;Matches URLs like www.domain.com and ftp.domain.com without the http: or ftp: protocol.&#13;&#10;The final character class makes sure that if an URL is part of some text, punctuation such as a comma or full stop after the URL is not interpreted as part of the URL.</description>
			<teststring><![CDATA[regexbuddy.com
www.regexbuddy.com
http://regexbuddy.com
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.
"www.domain.com/quoted URL with spaces"
support@regexbuddy.com]]></teststring>
		</action>
		<action id="URLFindinfulltextquotedemail" caseless="1" freespacing="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b(?:(?:(?:https?|ftp|file)://|www\.|ftp\.)[-A-Z0-9+&amp;@#/%?=~_|$!:,.;]*[-A-Z0-9+&amp;@#/%=~_|$]&#13;&#10;   | ((?:mailto:)?[A-Z0-9._%+-]+@[A-Z0-9._%-]+\.[A-Z]{2,})\b)&#13;&#10;|"(?:(?:https?|ftp|file)://|www\.|ftp\.)[^"\r\n]+"&#13;&#10;|'(?:(?:https?|ftp|file)://|www\.|ftp\.)[^'\r\n]+'</regex>
			<replace>{$&amp;}</replace>
			<description>URL: Find in full text (quoted + email)&#13;&#10;Matches unquoted URLs like "find in full text (protocol optional)".&#13;&#10;Matches email addresses with or without the mailto: protocol.&#13;&#10;Matches URLs between a pair of single or double quotes, allowing the URL to contain any character, except line breaks or the delimiting quote.</description>
			<teststring><![CDATA[regexbuddy.com
www.regexbuddy.com
http://regexbuddy.com
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.
"www.domain.com/quoted URL with spaces"
support@regexbuddy.com
fabio@email.validation.solutions]]></teststring>
		</action>
		<action id="URLFindinfulltextquoted" caseless="1" freespacing="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b(?:(?:https?|ftp|file)://|www\.|ftp\.)[-A-Z0-9+&amp;@#/%?=~_|$!:,.;]*[-A-Z0-9+&amp;@#/%=~_|$]&#13;&#10;|"(?:(?:https?|ftp|file)://|www\.|ftp\.)[^"\r\n]+"&#13;&#10;|'(?:(?:https?|ftp|file)://|www\.|ftp\.)[^'\r\n]+'</regex>
			<replace>{$&amp;}</replace>
			<description>URL: Find in full text (quoted)&#13;&#10;Matches unquoted URLs like "find in full text (protocol optional)".&#13;&#10;Matches URLs between a pair of single or double quotes, allowing the URL to contain any character, except line breaks or the delimiting quote.</description>
			<teststring><![CDATA[regexbuddy.com
www.regexbuddy.com
http://regexbuddy.com
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.
"www.domain.com/quoted URL with spaces"
support@regexbuddy.com]]></teststring>
		</action>
		<action id="URLFindinfulltextwithparentheses" caseless="1" freespacing="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b(?:(?:https?|ftp|file)://|www\.|ftp\.)&#13;&#10;  (?:\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[-A-Z0-9+&amp;@#/%=~_|$?!:,.])*&#13;&#10;  (?:\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[A-Z0-9+&amp;@#/%=~_|$])</regex>
			<description>URL: Find in full text (with parentheses)&#13;&#10;Matches URLs like www.domain.com and ftp.domain.com without the http: or ftp: protocol.&#13;&#10;Allows unnested pairs of parentheses in URLs.</description>
			<teststring><![CDATA[http://en.wikipedia.org/wiki/PC_Tools_(Central_Point_Software)
http://msdn.microsoft.com/en-us/library/aa752574(VS.85).aspx
http://www.domain.com/(a)(whole)(lot)(of)(brackets))
(http://en.wikipedia.org/wiki/PC_Tools_(Central_Point_Software)
(http://msdn.microsoft.com/en-us/library/aa752574(VS.85).aspx)
(http://www.domain.com/(a)(whole)(lot)(of)(brackets))
regexbuddy.com
www.regexbuddy.com
http://regexbuddy.com
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.
"www.domain.com/quoted URL with spaces"
support@regexbuddy.com]]></teststring>
		</action>
		<action id="URLFragment" caseless="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>#.+</regex>
			<description>URL: Fragment&#13;&#10;Extract the fragment from a string known to be a valid URL</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com:80/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top?dd
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLHost" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;[a-z][a-z0-9+\-.]*://               # Scheme&#13;&#10;([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?      # User&#13;&#10;(?&lt;host>[a-z0-9\-._~%]+             # Named or IPv4 host&#13;&#10;|\[[a-z0-9\-._~%!$&amp;'()*+,;=:]+\])   # IPv6+ host&#13;&#10;</regex>
			<description>URL: Host&#13;&#10;Extract the host from a string known to be a valid URL</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
ftp://anonymous@ftp.kernel.org
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLPath" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;# Skip over scheme and authority, if any&#13;&#10;([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?&#13;&#10;# Path&#13;&#10;(?&lt;path>[a-z0-9\-._~%!$&amp;'()*+,;=:@/]*)</regex>
			<description>URL: Path&#13;&#10;Extract the path from a string known to be a valid URL&#13;&#10;</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com:80/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLPort" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;[a-z][a-z0-9+\-.]*://               # Scheme&#13;&#10;([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?      # User&#13;&#10;([a-z0-9\-._~%]+                    # Named or IPv4 host&#13;&#10;|\[[a-z0-9\-._~%!$&amp;'()*+,;=:]+\])   # IPv6+ host&#13;&#10;:(?&lt;port>\d+)                       # Port number</regex>
			<description>URL: Port&#13;&#10;Extract the port number from a string known to be a valid URL</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com:80/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLQuery" caseless="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^[^?#]+\?([^#]+)</regex>
			<description>URL: Query&#13;&#10;Extract the query from a string known to be a valid URL</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com:80/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top?dd
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLReplaceURLswithHTMLlinks" purpose="replace" caseless="1" namedduplicate="1">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b(https?|ftp|file)://[-A-Z0-9+&amp;@#/%?=~_|!:,.;]*[A-Z0-9+&amp;@#/%=~_|]</regex>
			<replace>&lt;a href="$0">$0&lt;/a></replace>
			<description>URL: Replace URLs with HTML links</description>
			<teststring><![CDATA[http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/index.html?source=library
You can download RegexBuddy at http://www.regexbuddy.com/download.html.]]></teststring>
		</action>
		<action id="URLRFC3986" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;(# Scheme&#13;&#10; [a-z][a-z0-9+\-.]*:&#13;&#10; (# Authority &amp; path&#13;&#10;  //&#13;&#10;  ([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User&#13;&#10;  ([a-z0-9\-._~%]+                            # Named host&#13;&#10;  |\[[a-f0-9:.]+\]                            # IPv6 host&#13;&#10;  |\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host&#13;&#10;  (:[0-9]+)?                                  # Port&#13;&#10;  (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path&#13;&#10; |# Path without authority&#13;&#10;  (/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?&#13;&#10; )&#13;&#10;|# Relative URL (no scheme or authority)&#13;&#10; ([a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?  # Relative path&#10; |(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)+/?)                            # Absolute path&#10;)&#13;&#10;# Query&#13;&#10;(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?&#13;&#10;# Fragment&#13;&#10;(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?&#13;&#10;$</regex>
			<description>URL: RFC 3986&#13;&#10;Validate if a string holds a URL as specified in RFC 3986.  Both absolute and relative URLs are supported.</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLRFC3986namedcapture" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;(# Scheme&#13;&#10; (?&lt;scheme>[a-z][a-z0-9+\-.]*):&#13;&#10; (# Authority &amp; path&#13;&#10;  //&#13;&#10;  (?&lt;user>[a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User&#13;&#10;  (?&lt;host>[a-z0-9\-._~%]+                            # Named host&#13;&#10;  |       \[[a-f0-9:.]+\]                            # IPv6 host&#13;&#10;  |       \[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host&#13;&#10;  (?&lt;port>:[0-9]+)?                                  # Port&#13;&#10;  (?&lt;path>(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)        # Path&#13;&#10; |# Path without authority&#13;&#10;  (?&lt;path>/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?&#13;&#10; )&#13;&#10;|# Relative URL (no scheme or authority)&#13;&#10; (?&lt;path>[a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?  # Relative path&#10; |(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)+/?)                                   # Absolute path&#10;)&#13;&#10;# Query&#13;&#10;(?&lt;query>\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?&#13;&#10;# Fragment&#13;&#10;(?&lt;fragment>\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?&#13;&#10;$</regex>
			<description>URL: RFC 3986 (named capture)&#13;&#10;Validate if a string holds a URL as specified in RFC 3986.  Both absolute and relative URLs are supported.</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLRFC3986Host" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;[a-z][a-z0-9+\-.]*://                       # Scheme&#13;&#10;([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User&#13;&#10;(?&lt;host>[a-z0-9\-._~%]+                     # Named host&#13;&#10;|\[[a-f0-9:.]+\]                            # IPv6 host&#13;&#10;|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host&#13;&#10;(:[0-9]+)?                                  # Port&#13;&#10;(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path&#13;&#10;(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Query&#13;&#10;(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Fragment&#13;&#10;$</regex>
			<description>URL: RFC 3986 Host&#13;&#10;Validate if a string holds a URL as specified in RFC 3986, and extract its host.  The regex will only match URLs that actually specify a host.</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com:80/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLRFC3986Port" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;[a-z][a-z0-9+\-.]*://                       # Scheme&#13;&#10;([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User&#13;&#10;([a-z0-9\-._~%]+                            # Named host&#13;&#10;|\[[a-f0-9:.]+\]                            # IPv6 host&#13;&#10;|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host&#13;&#10;:(?&lt;port>[0-9]+)                            # Port&#13;&#10;(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path&#13;&#10;(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Query&#13;&#10;(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Fragment&#13;&#10;$</regex>
			<description>URL: RFC 3986 Port&#13;&#10;Validate if a string holds a URL as specified in RFC 3986, and extract its port number.  The regex will only match URLs that actually specify a port number.</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com:80/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLRFC3986Scheme" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;(?&lt;scheme>[a-z][a-z0-9+\-.]*):&#13;&#10;(# Authority &amp; path&#13;&#10; //&#13;&#10; ([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User&#13;&#10; ([a-z0-9\-._~%]+                            # Named host&#13;&#10; |\[[a-f0-9:.]+\]                            # IPv6 host&#13;&#10; |\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host&#13;&#10; (:[0-9]+)?                                  # Port&#13;&#10; (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path&#13;&#10;|# Path without authority&#13;&#10; (/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?&#13;&#10;)&#13;&#10;# Query&#13;&#10;(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?&#13;&#10;# Fragment&#13;&#10;(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?&#13;&#10;$</regex>
			<description>URL: RFC 3986 Scheme&#13;&#10;Validate if a string holds a URL as specified in RFC 3986, and extract its scheme.  The regex will only match absolute URLs (i.e. those that specify a scheme).</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLRFC3986User" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^&#13;&#10;[a-z][a-z0-9+\-.]*://                       # Scheme&#13;&#10;(?&lt;user>[a-z0-9\-._~%!$&amp;'()*+,;=]+)@        # User&#13;&#10;([a-z0-9\-._~%]+                            # Named host&#13;&#10;|\[[a-f0-9:.]+\]                            # IPv6 host&#13;&#10;|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host&#13;&#10;(:[0-9]+)?                                  # Port&#13;&#10;(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path&#13;&#10;(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Query&#13;&#10;(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Fragment&#13;&#10;$</regex>
			<description>URL: RFC 3986 User&#13;&#10;Validate if a string holds a URL as specified in RFC 3986, and extract its user.  The regex will only match URLs that actually specify a user.</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
ftp://anonymous@ftp.kernel.org
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLScheme" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^(?&lt;scheme>[a-z][a-z0-9+\-.]*):</regex>
			<description>URL: Scheme&#13;&#10;Extract the scheme from a string known to be a valid URL</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URLUser" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^[a-z0-9+\-.]+://(?&lt;user>[a-z0-9\-._~%!$&amp;'()*+,;=]+)@</regex>
			<description>URL: User&#13;&#10;Extract the user from a string known to be a valid URL</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://www.regexbuddy.com
http://www.regexbuddy.com/
http://www.regexbuddy.com/index.html
http://www.regexbuddy.com/cgi-bin/version.pl
http://www.regexbuddy.com/index.html#top
http://www.regexbuddy.com/index.html?param=value
http://www.regexbuddy.com/index.html?param=value#top
http://www.regexbuddy.com/index.html?param=value&param2=value2
ftp://anonymous@ftp.kernel.org
news:comp.software.shareware.authors
mailto:support@regexbuddy.com
ldap://[2001:db8::7]/c=GB?objectClass?one
tel:+1-816-555-1212
telnet://192.0.2.16:80/
../index.html
/index.html
index.html
/cgi-bin/version.pl
cgi-bin/version.pl]]></teststring>
		</action>
		<action id="URNFindinfulltext" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\burn:&#13;&#10;# Namespace Identifier&#13;&#10;[a-z0-9][a-z0-9-]{0,31}:&#13;&#10;# Namespace Specific String&#13;&#10;[a-z0-9()+,\-.:=@;$_!*'%/?#]*[a-z0-9+=@$/]</regex>
			<description>URN: Find in full text&#13;&#10;The final character class makes sure that if an URN is part of some text, punctuation such as a comma or full stop after the URN is not interpreted as part of the URN.</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2]]></teststring>
		</action>
		<action id="URNFindintext" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\burn:&#13;&#10;# Namespace Identifier&#13;&#10;[a-z0-9][a-z0-9-]{0,31}:&#13;&#10;# Namespace Specific String&#13;&#10;[a-z0-9()+,\-.:=@;$_!*'%/?#]+</regex>
			<description>URN: Find in text</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2]]></teststring>
		</action>
		<action id="URNValidate" caseless="1" freespacing="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>^urn:&#13;&#10;# Namespace Identifier&#13;&#10;[a-z0-9][a-z0-9-]{0,31}:&#13;&#10;# Namespace Specific String&#13;&#10;[a-z0-9()+,\-.:=@;$_!*'%/?#]+&#13;&#10;$</regex>
			<description>URN: Validate&#13;&#10;Check if a string holds a URN</description>
			<teststring><![CDATA[urn:oasis:names:specification:docbook:dtd:xml:4.1.2]]></teststring>
		</action>
		<action id="VATnumberAustria" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(AT)?U[0-9]{8}$</regex>
			<description>VAT number: Austria</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberBelgium" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(BE)?0[0-9]{9}$</regex>
			<description>VAT number: Belgium</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberBulgaria" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(BG)?[0-9]{9,10}$</regex>
			<description>VAT number: Bulgaria</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberCroatia" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(HR)?[0-9]{11}$</regex>
			<description>VAT number: Croatia</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberCyprus" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(CY)?[0-9]{8}[A-Z]$</regex>
			<description>VAT number: Cyprus</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberCzechRepublic" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(CZ)?[0-9]{8,10}$</regex>
			<description>VAT number: Czech Republic</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberDenmark" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(DK)?[0-9]{8}$</regex>
			<description>VAT number: Denmark</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberEstonia" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(EE)?[0-9]{9}$</regex>
			<description>VAT number: Estonia</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberFinland" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(FI)?[0-9]{8}$</regex>
			<description>VAT number: Finland</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberFrance" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(FR)?[0-9A-Z]{2}[0-9]{9}$</regex>
			<description>VAT number: France</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberGermany" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(DE)?[0-9]{9}$</regex>
			<description>VAT number: Germany</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberGreece" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(EL|GR)?[0-9]{9}$</regex>
			<description>VAT number: Greece</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberHungary" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(HU)?[0-9]{8}$</regex>
			<description>VAT number: Hungary</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberIreland" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(IE)?[0-9][0-9A-Z+*][0-9]{5}[A-Z]$</regex>
			<description>VAT number: Ireland</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberItaly" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(IT)?[0-9]{11}$</regex>
			<description>VAT number: Italy</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberLatvia" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(LV)?[0-9]{11}$</regex>
			<description>VAT number: Latvia</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberLithuania" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(LT)?([0-9]{9}|[0-9]{12})$</regex>
			<description>VAT number: Lithuania</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberLuxembourg" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(LU)?[0-9]{8}$</regex>
			<description>VAT number: Luxembourg</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberMalta" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(MT)?[0-9]{8}$</regex>
			<description>VAT number: Malta</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberNetherlands" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(NL)?[0-9]{9}B[0-9]{2}$</regex>
			<description>VAT number: Netherlands</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberPoland" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(PL)?[0-9]{10}$</regex>
			<description>VAT number: Poland</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberPortugal" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(PT)?[0-9]{9}$</regex>
			<description>VAT number: Portugal</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberRomania" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(RO)?[0-9]{2,10}$</regex>
			<description>VAT number: Romania</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberSlovakia" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(SK)?[0-9]{10}$</regex>
			<description>VAT number: Slovakia</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberSlovenia" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(SI)?[0-9]{8}$</regex>
			<description>VAT number: Slovenia</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberSpain" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(ES)?[0-9A-Z][0-9]{7}[0-9A-Z]$</regex>
			<description>VAT number: Spain</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberSweden" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(SE)?[0-9]{12}$</regex>
			<description>VAT number: Sweden</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="VATnumberUnitedKingdom" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^(GB)?([0-9]{9}([0-9]{3})?|GD[0-4][0-9][0-9]|HA[5-9][0-9][0-9])$</regex>
			<description>VAT number: United Kingdom</description>
			<teststring><![CDATA[ATU12345678
U12345678
BE0123456789
0123456789
BG123456789
123456789
BG0123456789
0123456789
CY12345678L
12345678L
CZ12345678
12345678
CZ123456789
123456789
CZ1234567890
1234567890
DE123456789
123456789
DK12345678
12345678
EE123456789
123456789
GR123456789
123456789
EL123456789
123456789
ES012345678
012345678
ESX1234567Y
X1234567Y
FI12345678
12345678
FR12123456789
12123456789
FRAB123456789
AB123456789
GB123456789
123456789
GB123456789123
123456789123
GBGD001
GD001
GBHA599
HA599
HR12345678901
12345678901
HU12345678
12345678
IE1S12345L
1S12345L
IT12345678901
12345678901
LT123456789
123456789
LT123456789012
123456789012
LU12345678
12345678
LV12345678901
12345678901
MT12345678
12345678
NL123456789B01
123456789B01
PL1234567890
1234567890
PT123456789
123456789
RO12345678
12345678
RO123456789
123456789
RO1234567890
1234567890
SE123456789012
123456789012
SI12345678
12345678
SK1234567890
1234567890
]]></teststring>
		</action>
		<action id="Weloveregularexpressions" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>((I|you|we|they)\s+love|s?he\s+loves)\s*reg(ular expressions?|ex(p|es)?)</regex>
			<description>We love regular expressions</description>
			<teststring><![CDATA[I love regex
You love regexp
He loves regular expression
We love regular expressions
They love regexes]]></teststring>
		</action>
		<action id="WordsAlphanumeric" caseless="1" multiline="1" namedduplicate="1" testscope="line">
			<flavor>
				<builtin>perl522</builtin>
			</flavor>
			<regex>\b[a-z]*(?>[a-z][0-9]+|[0-9]+[a-z])[a-z0-9]*\b</regex>
			<description>Words: Alphanumeric&#13;&#10;The word must contain at least one letter and at least one digit&#13;&#10;</description>
			<teststring><![CDATA[a
1
a1
1x
1l1
a1l
abc
abc123
abc123xyz
123xyz
123
abc123lmn456xyz]]></teststring>
		</action>
		<action id="WordsAnywordNOTmatchingaparticularregex">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:(?!%REGEX%)\w)+\b</regex>
			<description>Words: Any word NOT matching a particular regex&#13;&#10;&#13;&#10;This regex will match all words that cannot be matched by %REGEX%.&#13;&#10;&#13;&#10;Explanation: Observe that the negative lookahead and the \w+ are repeated together.  This makes sure we test that %REGEX% fails at EVERY position in the word, and not just at any particular position.</description>
			<parameter description="The regular expression the word should NOT match" defaultvalue="exclude">%REGEX%</parameter>
		</action>
		<action id="WordsDeleterepeatedwords" purpose="replace">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(\w+)(?:\s+\1\b)+</regex>
			<replace>$1</replace>
			<description>Words: Delete repeated words&#13;&#10;Find any word that occurs twice or more in a row.&#13;&#10;Delete all occurrences except the first.</description>
			<teststring><![CDATA[This is a repeated repeated word.]]></teststring>
		</action>
		<action id="WordsNearanyorder">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:word1(?:\W+\w+){1,3}?\W+word2|word2(?:\W+\w+){1,3}?\W+word1)\b</regex>
			<description>Words: Near, any order&#13;&#10;Matches word1 and word2, or vice versa, separated by at least 1 and at most 3 words</description>
			<teststring><![CDATA[word1 near word2
word2 reversed word1
word1 far far far far far word2]]></teststring>
		</action>
		<action id="WordsNearlist">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(word1|word2|word3)(?:\W+\w+){1,6}?\W+(word1|word2|word3)\b</regex>
			<description>Words: Near, list&#13;&#10;Matches any pair of words out of the list word1, word2, word3, separated by at least 1 and at most 6 words</description>
			<teststring><![CDATA[word1 near word2
word2 near near word3
word3 near near near word1
word2 near near near near word2
word1 far far far far far far far far word2]]></teststring>
		</action>
		<action id="WordsNearordered">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\bword1(?:\W+\w+){1,3}?\W+word2\b</regex>
			<description>Words: Near, ordered&#13;&#10;Matches word1 and word2, in that order, separated by at least 1 and at most 3 words</description>
			<teststring><![CDATA[word1 near word2
word2 reversed word1
word1 far far far far far word2]]></teststring>
		</action>
		<action id="WordsRepeatedwords">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(\w+)\s+\1\b</regex>
			<description>Words: Repeated words&#13;&#10;Find any word that occurs twice or more in a row.</description>
			<teststring><![CDATA[This is a repeated repeated word.]]></teststring>
		</action>
		<action id="WordsWholeword">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b%WORD%\b</regex>
			<description>Words: Whole word</description>
			<parameter description="The word you are looking for" defaultvalue="word">%WORD%</parameter>
		</action>
		<action id="WordsWholeword">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b(?:word1|word2|word3)\b</regex>
			<description>Words: Whole word&#13;&#10;Match one of the words from the list</description>
		</action>
		<action id="WordsWholewordattheendofaline" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b%WORD%\s*$</regex>
			<description>Words: Whole word at the end of a line&#13;&#10;Whitespace permitted after the word</description>
			<parameter description="The word you are looking for" defaultvalue="word">%WORD%</parameter>
		</action>
		<action id="WordsWholewordatthestartofaline" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^\s*%WORD%\b</regex>
			<description>Words: Whole word at the start of a line&#13;&#10;Whitespace permitted before the word</description>
			<parameter description="The word you are looking for" defaultvalue="word">%WORD%</parameter>
		</action>
		<action id="WordsWholewordattheveryendofaline" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>\b%WORD%$</regex>
			<description>Words: Whole word at the very end of a line</description>
			<parameter description="The word you are looking for" defaultvalue="word">%WORD%</parameter>
		</action>
		<action id="WordsWholewordattheverystartofaline" multiline="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^%WORD%\b</regex>
			<description>Words: Whole word at the very start of a line</description>
			<parameter description="The word you are looking for" defaultvalue="word">%WORD%</parameter>
		</action>
		<action id="XMLSchemaboolean" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>true|false|0|1</regex>
			<description>XML Schema: boolean</description>
			<teststring><![CDATA[true
false
0
1]]></teststring>
		</action>
		<action id="XMLSchemabyte" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+-]?0*(12[0-7]|1[0-1][0-9]|[0-9]{1,2})|-128</regex>
			<description>XML Schema: byte</description>
			<teststring><![CDATA[129
128
127
42
7
0
+129
+128
+127
+42
+7
+0
-129
-128
-127
-42
-7
-0
++7
--7
7+
7-]]></teststring>
		</action>
		<action id="XMLSchemadate" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-?([1-9][0-9]*)?[0-9]{4}-(1[0-2]|0[1-9])-(3[0-1]|0[1-9]|[1-2][0-9])(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: date</description>
			<teststring><![CDATA[2008-07-01+07:00
16:41:27.123+07:00
2008-07-01T16:41:27.123+07:00
]]></teststring>
		</action>
		<action id="XMLSchemadateTime" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-?([1-9][0-9]*)?[0-9]{4}-(1[0-2]|0[1-9])-(3[0-1]|0[1-9]|[1-2][0-9])T(2[0-3]|[0-1][0-9]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: dateTime</description>
			<teststring><![CDATA[2008-07-01+07:00
16:41:27.123+07:00
2008-07-01T16:41:27.123+07:00
]]></teststring>
		</action>
		<action id="XMLSchemadecimal" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)</regex>
			<description>XML Schema: decimal</description>
			<teststring><![CDATA[+1234.5678
.5678
1234.
]]></teststring>
		</action>
		<action id="XMLSchemadurationlookahead" testscope="line">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>^-?P(?=T?[0-9])([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T(?=[0-9])([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9]+)?S)?)?$</regex>
			<description>XML Schema: duration (lookahead)&#13;&#10;Uses lookaround to codify that at least one number and designator must appear, and that T must not appear if no time designators appear.&#13;&#10;The lookahead makes this regular expression much simpler than the "strict" version, while still being equally strict.  Lookahead is not supported by the XML Schema regular expression flavor.</description>
			<teststring><![CDATA[Valid:
P2Y6M5DT12H35M30S
-P2Y
P6M
P5D
PT12H
PT

Invalid:
P
T
PT
P12H
P12YT]]></teststring>
		</action>
		<action id="XMLSchemadurationloose" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9]+)?S)?)?</regex>
			<description>XML Schema: duration (loose)&#13;&#10;Allows durations without any designators, and allows T without any time designators.  Such values do not follow the XML Schema spec.&#13;&#10;Allowing these invalid durations does yield a significantly simpler regular expression.</description>
			<teststring><![CDATA[Valid:
P2Y6M5DT12H35M30S
-P2Y
P6M
P5D
PT12H
PT

Invalid:
P
T
PT
P12H
P12YT]]></teststring>
		</action>
		<action id="XMLSchemadurationstrict" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-?P([0-9]+Y([0-9]+M)?([0-9]+D)?(T([0-9]+H([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|[0-9]+M([0-9]+(\.[0-9]+)?S)?))?|[0-9]+M([0-9]+D)?(T([0-9]+H([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|[0-9]+M([0-9]+(\.[0-9]+)?S)?))?|[0-9]+D(T([0-9]+H([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|[0-9]+M([0-9]+(\.[0-9]+)?S)?))?|T([0-9]+H([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|[0-9]+M([0-9]+(\.[0-9]+)?S)?))</regex>
			<description>XML Schema: duration (strict)&#13;&#10;Codifies that at least one number and designator must appear, and that T must not appear if no time designators appear.&#13;&#10;This unwieldy regular expression works with any regex flavor.  If your regex flavor supports lookahead, you can use the "lookahead" version instead, which is much simpler, but equally strict.</description>
			<teststring><![CDATA[Valid:
P2Y6M5DT12H35M30S
-P2Y
P6M
P5D
PT12H
PT

Invalid:
P
T
PT
P12H
P12YT]]></teststring>
		</action>
		<action id="XMLSchemafloat" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)([eE]-?[0-9]+)?|-?INF|NaN</regex>
			<description>XML Schema: float</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchemagDay">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>---(3[0-1]|0[1-9]|[1-2][0-9])(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: gDay</description>
		</action>
		<action id="XMLSchemagMonth">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>--(1[0-2]|0[1-9])(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: gMonth</description>
		</action>
		<action id="XMLSchemagMonthDay">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>--(1[0-2]|0[1-9])-(3[0-1]|0[1-9]|[1-2][0-9])(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: gMonthDay</description>
		</action>
		<action id="XMLSchemagYear">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-?([1-9][0-9]*)?[0-9]{4}(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: gYear</description>
		</action>
		<action id="XMLSchemagYearMonth">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-?([1-9][0-9]*)?[0-9]{4}-(1[0-2]|0[1-9])(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: gYearMonth</description>
		</action>
		<action id="XMLSchemahexBase64">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/]{4})*([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/]{3}=|[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/]{2}==)?</regex>
			<description>XML Schema: hexBase64&#13;&#10;Regex allows a zero-length match, because hexBase64 allows empty values</description>
		</action>
		<action id="XMLSchemahexBinary">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>([0-9A-Fa-f][0-9A-Fa-f])*</regex>
			<description>XML Schema: hexBinary&#13;&#10;Regex allows a zero-length match, because hexBinary allows empty values</description>
		</action>
		<action id="XMLSchemaint" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+-]?0*(214748364[0-7]|21474836[0-3][0-9]|2147483[0-5][0-9]{2}|214748[0-2][0-9]{3}|21474[0-7][0-9]{4}|2147[0-3][0-9]{5}|214[0-6][0-9]{6}|21[0-3][0-9]{7}|20[0-9]{8}|[0-1]?[0-9]{1,9})|-2147483678</regex>
			<description>XML Schema: int</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchemaInteger" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+-]?[0-9]+</regex>
			<description>XML Schema: Integer</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchemaLanguageany" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[a-z]{2}-[A-Z]{2}</regex>
			<description>XML Schema: Language (any)</description>
			<teststring><![CDATA[en-US
qq-QQ
en
US
enUS
ENus
EN-us]]></teststring>
		</action>
		<action id="XMLSchemaLanguagelist" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>(a[abfmrsyz]|b[aeghinor]|c[aosy]|d[aez]|e[lnostu]|f[aijory]|g[adlnu]|h[airuy]|i[aeknstw]|j[aiw]|k[aklmnosuy]|l[anotv]|m[giklnorsty]|n[aelo]|o[cmr]|p[alstu]|r[mnouw]|s[adghiklmnoqrstuvw]|t[aeghiklnorstw]|u[krz]|v[io]|wo|xh|yo|z[hu])-(A[DEFGILMNOQRSTUWXZ]|B[ABDEFGHIJLMNORSTVWYZ]|C[ACDFGHIKLMNORUVXYZ]|D[EJKMOZ]|E[CEEGHRSTIJKMOR]|G[ABDEFGHILMNPQRSTUWY]|H[KMNRTU]|I[DELMNOQRST]|J[EMOP]|K[EGHIMNPRWYZ]|L[ABCIKRSTUVY]|M[ACDEFGHKLMNOPQRSTUVWXYZ]|N[ACEFGILOPRUZ]|OM|P[AEFGHKLMNRSTWY]|QA|R[EOSUW]|S[ABCDEGHIJKLMNORTVYZ]|T[CDFGHJKLMNORTVWZ]|U[AGMSYZ]|V[ACEGINU]|W[FS]|Y[ET]|Z[AMW])</regex>
			<description>XML Schema: Language (list)</description>
			<teststring><![CDATA[en-US
qq-QQ
en
US
enUS
ENus
EN-us]]></teststring>
		</action>
		<action id="XMLSchemaName" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>\i\c*</regex>
			<description>XML Schema: Name</description>
			<teststring><![CDATA[rxb:regexbuddy
regex]]></teststring>
		</action>
		<action id="XMLSchemaNCName" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[\i-[:]][\c-[:]]*</regex>
			<description>XML Schema: NCName</description>
			<teststring><![CDATA[rxb:regexbuddy
regex]]></teststring>
		</action>
		<action id="XMLSchemaNCNamelist" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[\i-[:]][\c-[:]]*(\s+[\i-[:]][\c-[:]]*)*</regex>
			<description>XML Schema: NCName list&#13;&#10;Can be used for IDREFS and ENTITIES types</description>
			<teststring><![CDATA[rxb:regexbuddy
regex action]]></teststring>
		</action>
		<action id="XMLSchemanegativeInteger" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-0*[1-9][0-9]*</regex>
			<description>XML Schema: negativeInteger</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchemanonNegativeInteger" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+]?[0-9]+</regex>
			<description>XML Schema: nonNegativeInteger</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchemanonPositiveInteger" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>-[0-9]+|0</regex>
			<description>XML Schema: nonPositiveInteger</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchemapositiveInteger" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+]?0*[1-9][0-9]*</regex>
			<description>XML Schema: positiveInteger</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchemaQName" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[\i-[:]][\c-[:]]*(:[\i-[:]][\c-[:]]*)?</regex>
			<description>XML Schema: QName</description>
			<teststring><![CDATA[rxb:regexbuddy
regex]]></teststring>
		</action>
		<action id="XMLSchemashort" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>[+-]?0*(3276[0-7]|327[0-5][0-9]|32[0-6][0-9]{2}|3[0-1][0-9]{3}|[0-2]?[0-9]{1,4})|-32768</regex>
			<description>XML Schema: short</description>
			<teststring><![CDATA[1234
-1234
+1234.5678
.5678
1234.
+1234.5678e90
INF
NaN
.
]]></teststring>
		</action>
		<action id="XMLSchematime" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>(2[0-3]|[0-1][0-9]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?(Z|[+-](2[0-3]|[0-1][0-9]):[0-5][0-9])?</regex>
			<description>XML Schema: time</description>
			<teststring><![CDATA[2008-07-01+07:00
16:41:27.123+07:00
2008-07-01T16:41:27.123+07:00
]]></teststring>
		</action>
		<action id="XMLSchemaunsignedByte" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>\+?0*(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})</regex>
			<description>XML Schema: unsignedByte</description>
			<teststring><![CDATA[129
128
127
42
7
0
+129
+128
+127
+42
+7
+0
-129
-128
-127
-42
-7
-0
++7
--7
7+
7-]]></teststring>
		</action>
		<action id="XMLSchemaunsignedShort" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>\+?0*(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[0-5]?[0-9]{1,4})</regex>
			<description>XML Schema: unsignedShort</description>
			<teststring><![CDATA[129
128
127
42
7
0
+129
+128
+127
+42
+7
+0
-129
-128
-127
-42
-7
-0
++7
--7
7+
7-]]></teststring>
		</action>
		<action id="XMLAnyclosingtag" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>&lt;/\i\c*\s*></regex>
			<description>XML: Any closing tag</description>
			<teststring><![CDATA[<action flavor="xml">
<regex>
<empty/>
</regex>
</action>]]></teststring>
		</action>
		<action id="XMLAnyopeningorclosingtag" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>&lt;(\i\c*(\s+\i\c*\s*=\s*("[^"]*"|'[^']*'))*|/\i\c*)\s*></regex>
			<description>XML: Any opening or closing tag</description>
			<teststring><![CDATA[<action flavor="xml">
<regex>
<empty/>
</regex>
</action>]]></teststring>
		</action>
		<action id="XMLAnyopeningtag" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>&lt;\i\c*(\s+\i\c*\s*=\s*("[^"]*"|'[^']*'))*\s*></regex>
			<description>XML: Any opening tag</description>
			<teststring><![CDATA[<action flavor="xml">
<regex>
<empty/>
</regex>
</action>]]></teststring>
		</action>
		<action id="XMLAnyopeningtagwithoutattributes" testscope="line">
			<flavor>
				<builtin>xml</builtin>
			</flavor>
			<regex>&lt;\i\c*\s*></regex>
			<description>XML: Any opening tag without attributes</description>
			<teststring><![CDATA[<action flavor="xml">
<regex>
<empty/>
</regex>
</action>]]></teststring>
		</action>
		<action id="XMLnormalizedStringtoken" purpose="replace" multiline="1">
			<flavor>
				<builtin>xpath</builtin>
			</flavor>
			<regex>^ +|( ){2,}| +$</regex>
			<replace>$1</replace>
			<description>XML: normalizedString -> token&#13;&#10;Convert a normalized string (i.e. one without tabs and line breaks) to a token by collapsing consecutive spaces, and trimming leading and trailing spaces.</description>
			<teststring><![CDATA[ A normalized string with many   spaces]]></teststring>
		</action>
		<action id="XMLReplaceinvalidcharactersallowallentities" purpose="replace" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&amp;(?!(?:[a-z]+|#[0-9]+|#x[0-9a-f]+);)</regex>
			<replace>&amp;amp;</replace>
			<description>XML: Replace invalid &amp; characters (allow all entities)</description>
			<teststring><![CDATA[1 < 2
1 < 2 & 2 > 1
<tag> &entity;
<tag attribute>
<tag attribute='value'>
<no tag &amp; <tag>]]></teststring>
		</action>
		<action id="XMLReplaceinvalidcharactersallowonlystandardentities" purpose="replace" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&amp;(?!(?:[lg]t|amp|apos|quot|#[0-9]+|#x[0-9a-f]+);)</regex>
			<replace>&amp;amp;</replace>
			<description>XML: Replace invalid &amp; characters (allow only standard entities)</description>
			<teststring><![CDATA[1 < 2
1 < 2 & 2 > 1
<tag> &entity;
<tag attribute>
<tag attribute='value'>
<no tag &amp; <tag>]]></teststring>
		</action>
		<action id="XMLReplaceinvalidcharactersexactregex" purpose="replace" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;(?![_:a-z][-._:a-z0-9]*\b(?:/|\s+[_:a-z][-._:a-z0-9]*(?:\s*=\s*(?:'[^']*'|"[^"]*"))?)*\s*>)</regex>
			<replace>&amp;lt;</replace>
			<description>XML: Replace invalid &lt; characters (exact regex)</description>
			<teststring><![CDATA[1 < 2
1 < 2 & 2 > 1
<tag> &entity;
<tag attribute>
<tag attribute='value'>
<no tag &amp; <tag>]]></teststring>
		</action>
		<action id="XMLReplaceinvalidcharacterssimpleregex" purpose="replace" caseless="1">
			<flavor>
				<builtin>java8</builtin>
			</flavor>
			<regex>&lt;(?![_:a-z][-._:a-z0-9]*\b[^&lt;>]*>)</regex>
			<replace>&amp;lt;</replace>
			<description>XML: Replace invalid &lt; characters (simple regex)</description>
			<teststring><![CDATA[1 < 2
1 < 2 & 2 > 1
<tag> &entity;
<tag attribute>
<tag attribute='value'>
<no tag &amp; <tag>]]></teststring>
		</action>
		<action id="XMLstringnormalizedString" purpose="replace">
			<flavor>
				<builtin>xpath</builtin>
			</flavor>
			<regex>[\r\n\t]</regex>
			<replace> </replace>
			<description>XML: string -> normalizedString&#13;&#10;Normalize a string by replacing all tabs and line breaks with spaces</description>
			<teststring><![CDATA[	A string with many   spaces
on two lines]]></teststring>
		</action>
	</libraryfile>
</rxb:regexbuddy>
